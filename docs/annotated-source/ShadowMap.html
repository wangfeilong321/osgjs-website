<!DOCTYPE html>

<html>
<head>
  <title>ShadowMap.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="OSG.html">
                OSG.js
              </a>
            
              
              <a class="source" href="BillboardAttribute.html">
                BillboardAttribute.js
              </a>
            
              
              <a class="source" href="BlendColor.html">
                BlendColor.js
              </a>
            
              
              <a class="source" href="BlendFunc.html">
                BlendFunc.js
              </a>
            
              
              <a class="source" href="BoundingBox.html">
                BoundingBox.js
              </a>
            
              
              <a class="source" href="BoundingSphere.html">
                BoundingSphere.js
              </a>
            
              
              <a class="source" href="BufferArray.html">
                BufferArray.js
              </a>
            
              
              <a class="source" href="BufferArrayProxy.html">
                BufferArrayProxy.js
              </a>
            
              
              <a class="source" href="Camera.html">
                Camera.js
              </a>
            
              
              <a class="source" href="ColorMask.html">
                ColorMask.js
              </a>
            
              
              <a class="source" href="ComputeBoundsVisitor.html">
                ComputeBoundsVisitor.js
              </a>
            
              
              <a class="source" href="ComputeMatrixFromNodePath.html">
                ComputeMatrixFromNodePath.js
              </a>
            
              
              <a class="source" href="CullFace.html">
                CullFace.js
              </a>
            
              
              <a class="source" href="CullSettings.html">
                CullSettings.js
              </a>
            
              
              <a class="source" href="CullStack.html">
                CullStack.js
              </a>
            
              
              <a class="source" href="CullVisitor.html">
                CullVisitor.js
              </a>
            
              
              <a class="source" href="CullingSet.html">
                CullingSet.js
              </a>
            
              
              <a class="source" href="Depth.html">
                Depth.js
              </a>
            
              
              <a class="source" href="DrawArrayLengths.html">
                DrawArrayLengths.js
              </a>
            
              
              <a class="source" href="DrawArrays.html">
                DrawArrays.js
              </a>
            
              
              <a class="source" href="DrawElements.html">
                DrawElements.js
              </a>
            
              
              <a class="source" href="EllipsoidModel.html">
                EllipsoidModel.js
              </a>
            
              
              <a class="source" href="FrameBufferObject.html">
                FrameBufferObject.js
              </a>
            
              
              <a class="source" href="FrameStamp.html">
                FrameStamp.js
              </a>
            
              
              <a class="source" href="GLObject.html">
                GLObject.js
              </a>
            
              
              <a class="source" href="Geometry.html">
                Geometry.js
              </a>
            
              
              <a class="source" href="Image.html">
                Image.js
              </a>
            
              
              <a class="source" href="ImageStream.html">
                ImageStream.js
              </a>
            
              
              <a class="source" href="KdTree.html">
                KdTree.js
              </a>
            
              
              <a class="source" href="KdTreeBuilder.html">
                KdTreeBuilder.js
              </a>
            
              
              <a class="source" href="KdTreeRayIntersector.html">
                KdTreeRayIntersector.js
              </a>
            
              
              <a class="source" href="KdTreeSphereIntersector.html">
                KdTreeSphereIntersector.js
              </a>
            
              
              <a class="source" href="Light.html">
                Light.js
              </a>
            
              
              <a class="source" href="LightSource.html">
                LightSource.js
              </a>
            
              
              <a class="source" href="LineWidth.html">
                LineWidth.js
              </a>
            
              
              <a class="source" href="Lod.html">
                Lod.js
              </a>
            
              
              <a class="source" href="Map.html">
                Map.js
              </a>
            
              
              <a class="source" href="Material.html">
                Material.js
              </a>
            
              
              <a class="source" href="Math.html">
                Math.js
              </a>
            
              
              <a class="source" href="Matrix.html">
                Matrix.js
              </a>
            
              
              <a class="source" href="MatrixMemoryPool.html">
                MatrixMemoryPool.js
              </a>
            
              
              <a class="source" href="MatrixTransform.html">
                MatrixTransform.js
              </a>
            
              
              <a class="source" href="Node.html">
                Node.js
              </a>
            
              
              <a class="source" href="NodeVisitor.html">
                NodeVisitor.js
              </a>
            
              
              <a class="source" href="Notify.html">
                Notify.js
              </a>
            
              
              <a class="source" href="Object.html">
                Object.js
              </a>
            
              
              <a class="source" href="Options.html">
                Options.js
              </a>
            
              
              <a class="source" href="PagedLOD.html">
                PagedLOD.js
              </a>
            
              
              <a class="source" href="Plane.html">
                Plane.js
              </a>
            
              
              <a class="source" href="Polytope.html">
                Polytope.js
              </a>
            
              
              <a class="source" href="PrimitiveFunctor.html">
                PrimitiveFunctor.js
              </a>
            
              
              <a class="source" href="PrimitiveSet.html">
                PrimitiveSet.js
              </a>
            
              
              <a class="source" href="Program.html">
                Program.js
              </a>
            
              
              <a class="source" href="Projection.html">
                Projection.js
              </a>
            
              
              <a class="source" href="Quat.html">
                Quat.js
              </a>
            
              
              <a class="source" href="RenderBin.html">
                RenderBin.js
              </a>
            
              
              <a class="source" href="RenderLeaf.html">
                RenderLeaf.js
              </a>
            
              
              <a class="source" href="RenderStage.html">
                RenderStage.js
              </a>
            
              
              <a class="source" href="Shader.html">
                Shader.js
              </a>
            
              
              <a class="source" href="Shape.html">
                Shape.js
              </a>
            
              
              <a class="source" href="Stack.html">
                Stack.js
              </a>
            
              
              <a class="source" href="State.html">
                State.js
              </a>
            
              
              <a class="source" href="StateAttribute.html">
                StateAttribute.js
              </a>
            
              
              <a class="source" href="StateGraph.html">
                StateGraph.js
              </a>
            
              
              <a class="source" href="StateSet.html">
                StateSet.js
              </a>
            
              
              <a class="source" href="Texture.html">
                Texture.js
              </a>
            
              
              <a class="source" href="TextureCubeMap.html">
                TextureCubeMap.js
              </a>
            
              
              <a class="source" href="TextureManager.html">
                TextureManager.js
              </a>
            
              
              <a class="source" href="Timer.html">
                Timer.js
              </a>
            
              
              <a class="source" href="Transform.html">
                Transform.js
              </a>
            
              
              <a class="source" href="TransformEnums.html">
                TransformEnums.js
              </a>
            
              
              <a class="source" href="TriangleIndexFunctor.html">
                TriangleIndexFunctor.js
              </a>
            
              
              <a class="source" href="Uniform.html">
                Uniform.js
              </a>
            
              
              <a class="source" href="UpdateVisitor.html">
                UpdateVisitor.js
              </a>
            
              
              <a class="source" href="Utils.html">
                Utils.js
              </a>
            
              
              <a class="source" href="Vec2.html">
                Vec2.js
              </a>
            
              
              <a class="source" href="Vec3.html">
                Vec3.js
              </a>
            
              
              <a class="source" href="Vec4.html">
                Vec4.js
              </a>
            
              
              <a class="source" href="Viewport.html">
                Viewport.js
              </a>
            
              
              <a class="source" href="WebGLCaps.html">
                WebGLCaps.js
              </a>
            
              
              <a class="source" href="osg.html">
                osg.js
              </a>
            
              
              <a class="source" href="Animation.html">
                Animation.js
              </a>
            
              
              <a class="source" href="AnimationUpdateCallback.html">
                AnimationUpdateCallback.js
              </a>
            
              
              <a class="source" href="BasicAnimationManager.html">
                BasicAnimationManager.js
              </a>
            
              
              <a class="source" href="Bone.html">
                Bone.js
              </a>
            
              
              <a class="source" href="Channel.html">
                Channel.js
              </a>
            
              
              <a class="source" href="CollectAnimationUpdateCallbackVisitor.html">
                CollectAnimationUpdateCallbackVisitor.js
              </a>
            
              
              <a class="source" href="CollectBoneVisitor.html">
                CollectBoneVisitor.js
              </a>
            
              
              <a class="source" href="Easing.html">
                Easing.js
              </a>
            
              
              <a class="source" href="FindNearestParentSkeleton.html">
                FindNearestParentSkeleton.js
              </a>
            
              
              <a class="source" href="Interpolator.html">
                Interpolator.js
              </a>
            
              
              <a class="source" href="MorphAttribute.html">
                MorphAttribute.js
              </a>
            
              
              <a class="source" href="MorphGeometry.html">
                MorphGeometry.js
              </a>
            
              
              <a class="source" href="RigGeometry.html">
                RigGeometry.js
              </a>
            
              
              <a class="source" href="RigTransformHardware.html">
                RigTransformHardware.js
              </a>
            
              
              <a class="source" href="Skeleton.html">
                Skeleton.js
              </a>
            
              
              <a class="source" href="SkinningAttribute.html">
                SkinningAttribute.js
              </a>
            
              
              <a class="source" href="StackedMatrix.html">
                StackedMatrix.js
              </a>
            
              
              <a class="source" href="StackedQuaternion.html">
                StackedQuaternion.js
              </a>
            
              
              <a class="source" href="StackedRotateAxis.html">
                StackedRotateAxis.js
              </a>
            
              
              <a class="source" href="StackedScale.html">
                StackedScale.js
              </a>
            
              
              <a class="source" href="StackedTranslate.html">
                StackedTranslate.js
              </a>
            
              
              <a class="source" href="Target.html">
                Target.js
              </a>
            
              
              <a class="source" href="UpdateBone.html">
                UpdateBone.js
              </a>
            
              
              <a class="source" href="UpdateMatrixTransform.html">
                UpdateMatrixTransform.js
              </a>
            
              
              <a class="source" href="UpdateMorph.html">
                UpdateMorph.js
              </a>
            
              
              <a class="source" href="UpdateRigGeometry.html">
                UpdateRigGeometry.js
              </a>
            
              
              <a class="source" href="UpdateSkeleton.html">
                UpdateSkeleton.js
              </a>
            
              
              <a class="source" href="channelType.html">
                channelType.js
              </a>
            
              
              <a class="source" href="osgAnimation.html">
                osgAnimation.js
              </a>
            
              
              <a class="source" href="DatabasePager.html">
                DatabasePager.js
              </a>
            
              
              <a class="source" href="Input.html">
                Input.js
              </a>
            
              
              <a class="source" href="Options.html">
                Options.js
              </a>
            
              
              <a class="source" href="ReaderParser.html">
                ReaderParser.js
              </a>
            
              
              <a class="source" href="osgDB.html">
                osgDB.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulator.html">
                FirstPersonManipulator.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulatorDeviceOrientationController.html">
                FirstPersonManipulatorDeviceOrientationController.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulatorHammerController.html">
                FirstPersonManipulatorHammerController.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulatorStandardMouseKeyboardController.html">
                FirstPersonManipulatorStandardMouseKeyboardController.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulatorWebVRController.html">
                FirstPersonManipulatorWebVRController.js
              </a>
            
              
              <a class="source" href="Manipulator.html">
                Manipulator.js
              </a>
            
              
              <a class="source" href="OrbitManipulator.html">
                OrbitManipulator.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorDeviceOrientationController.html">
                OrbitManipulatorDeviceOrientationController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorEnums.html">
                OrbitManipulatorEnums.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorGamePadController.html">
                OrbitManipulatorGamePadController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorHammerController.html">
                OrbitManipulatorHammerController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorLeapMotionController.html">
                OrbitManipulatorLeapMotionController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorStandardMouseKeyboardController.html">
                OrbitManipulatorStandardMouseKeyboardController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorWebVRController.html">
                OrbitManipulatorWebVRController.js
              </a>
            
              
              <a class="source" href="SwitchManipulator.html">
                SwitchManipulator.js
              </a>
            
              
              <a class="source" href="osgGA.html">
                osgGA.js
              </a>
            
              
              <a class="source" href="osgNameSpace.html">
                osgNameSpace.js
              </a>
            
              
              <a class="source" href="Compiler.html">
                Compiler.js
              </a>
            
              
              <a class="source" href="ShaderGenerator.html">
                ShaderGenerator.js
              </a>
            
              
              <a class="source" href="ShaderGeneratorProxy.html">
                ShaderGeneratorProxy.js
              </a>
            
              
              <a class="source" href="ShaderProcessor.html">
                ShaderProcessor.js
              </a>
            
              
              <a class="source" href="node.html">
                node.js
              </a>
            
              
              <a class="source" href="Node.html">
                Node.js
              </a>
            
              
              <a class="source" href="data.html">
                data.js
              </a>
            
              
              <a class="source" href="functions.html">
                functions.js
              </a>
            
              
              <a class="source" href="lights.html">
                lights.js
              </a>
            
              
              <a class="source" href="morph.html">
                morph.js
              </a>
            
              
              <a class="source" href="operations.html">
                operations.js
              </a>
            
              
              <a class="source" href="shadows.html">
                shadows.js
              </a>
            
              
              <a class="source" href="skinning.html">
                skinning.js
              </a>
            
              
              <a class="source" href="textures.html">
                textures.js
              </a>
            
              
              <a class="source" href="nodeFactory.html">
                nodeFactory.js
              </a>
            
              
              <a class="source" href="osgShader.html">
                osgShader.js
              </a>
            
              
              <a class="source" href="shaderLib.html">
                shaderLib.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
              
              <a class="source" href="ShadowCastAttribute.html">
                ShadowCastAttribute.js
              </a>
            
              
              <a class="source" href="ShadowCastCompiler.html">
                ShadowCastCompiler.js
              </a>
            
              
              <a class="source" href="ShadowCastShaderGenerator.html">
                ShadowCastShaderGenerator.js
              </a>
            
              
              <a class="source" href="ShadowCasterVisitor.html">
                ShadowCasterVisitor.js
              </a>
            
              
              <a class="source" href="ShadowFrustumIntersection.html">
                ShadowFrustumIntersection.js
              </a>
            
              
              <a class="source" href="ShadowMap.html">
                ShadowMap.js
              </a>
            
              
              <a class="source" href="ShadowReceiveAttribute.html">
                ShadowReceiveAttribute.js
              </a>
            
              
              <a class="source" href="ShadowSettings.html">
                ShadowSettings.js
              </a>
            
              
              <a class="source" href="ShadowTechnique.html">
                ShadowTechnique.js
              </a>
            
              
              <a class="source" href="ShadowTexture.html">
                ShadowTexture.js
              </a>
            
              
              <a class="source" href="ShadowedScene.html">
                ShadowedScene.js
              </a>
            
              
              <a class="source" href="osgShadow.html">
                osgShadow.js
              </a>
            
              
              <a class="source" href="shaderLib.html">
                shaderLib.js
              </a>
            
              
              <a class="source" href="Text.html">
                Text.js
              </a>
            
              
              <a class="source" href="osgText.html">
                osgText.js
              </a>
            
              
              <a class="source" href="Composer.html">
                Composer.js
              </a>
            
              
              <a class="source" href="DisplayGeometryVisitor.html">
                DisplayGeometryVisitor.js
              </a>
            
              
              <a class="source" href="DisplayGraph.html">
                DisplayGraph.js
              </a>
            
              
              <a class="source" href="DisplayGraphNode.html">
                DisplayGraphNode.js
              </a>
            
              
              <a class="source" href="DisplayGraphRenderer.html">
                DisplayGraphRenderer.js
              </a>
            
              
              <a class="source" href="DisplayNormalVisitor.html">
                DisplayNormalVisitor.js
              </a>
            
              
              <a class="source" href="GizmoGeometry.html">
                GizmoGeometry.js
              </a>
            
              
              <a class="source" href="IntersectionVisitor.html">
                IntersectionVisitor.js
              </a>
            
              
              <a class="source" href="LineSegmentIntersector.html">
                LineSegmentIntersector.js
              </a>
            
              
              <a class="source" href="NodeGizmo.html">
                NodeGizmo.js
              </a>
            
              
              <a class="source" href="ParameterVisitor.html">
                ParameterVisitor.js
              </a>
            
              
              <a class="source" href="PolytopeIntersector.html">
                PolytopeIntersector.js
              </a>
            
              
              <a class="source" href="PolytopePrimitiveIntersector.html">
                PolytopePrimitiveIntersector.js
              </a>
            
              
              <a class="source" href="SphereIntersector.html">
                SphereIntersector.js
              </a>
            
              
              <a class="source" href="TangentSpaceGenerator.html">
                TangentSpaceGenerator.js
              </a>
            
              
              <a class="source" href="TriangleIntersector.html">
                TriangleIntersector.js
              </a>
            
              
              <a class="source" href="TriangleSphereIntersector.html">
                TriangleSphereIntersector.js
              </a>
            
              
              <a class="source" href="WebVR.html">
                WebVR.js
              </a>
            
              
              <a class="source" href="WebVRCustom.html">
                WebVRCustom.js
              </a>
            
              
              <a class="source" href="osgPool.html">
                osgPool.js
              </a>
            
              
              <a class="source" href="osgUtil.html">
                osgUtil.js
              </a>
            
              
              <a class="source" href="Renderer.html">
                Renderer.js
              </a>
            
              
              <a class="source" href="Scene.html">
                Scene.js
              </a>
            
              
              <a class="source" href="View.html">
                View.js
              </a>
            
              
              <a class="source" href="Viewer.html">
                Viewer.js
              </a>
            
              
              <a class="source" href="createStats.html">
                createStats.js
              </a>
            
              
              <a class="source" href="DeviceOrientation.html">
                DeviceOrientation.js
              </a>
            
              
              <a class="source" href="EventProxy.html">
                EventProxy.js
              </a>
            
              
              <a class="source" href="GamePad.html">
                GamePad.js
              </a>
            
              
              <a class="source" href="Hammer.html">
                Hammer.js
              </a>
            
              
              <a class="source" href="LeapMotion.html">
                LeapMotion.js
              </a>
            
              
              <a class="source" href="StandardMouseKeyboard.html">
                StandardMouseKeyboard.js
              </a>
            
              
              <a class="source" href="WebVR.html">
                WebVR.js
              </a>
            
              
              <a class="source" href="osgViewer.html">
                osgViewer.js
              </a>
            
              
              <a class="source" href="webgl-debug.html">
                webgl-debug.js
              </a>
            
              
              <a class="source" href="webgl-utils.html">
                webgl-utils.js
              </a>
            
              
              <a class="source" href="osgWrappers.html">
                osgWrappers.js
              </a>
            
              
              <a class="source" href="osg.html">
                osg.js
              </a>
            
              
              <a class="source" href="osgAnimation.html">
                osgAnimation.js
              </a>
            
              
              <a class="source" href="osgText.html">
                osgText.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>ShadowMap.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-meta">'use strict'</span>;
<span class="hljs-keyword">var</span> Camera = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Camera'</span> );
<span class="hljs-keyword">var</span> BlendFunc = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/BlendFunc'</span> );
<span class="hljs-keyword">var</span> ComputeBoundsVisitor = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/ComputeBoundsVisitor'</span> );
<span class="hljs-keyword">var</span> Depth = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Depth'</span> );
<span class="hljs-keyword">var</span> FrameBufferObject = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/FrameBufferObject'</span> );
<span class="hljs-keyword">var</span> Matrix = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Matrix'</span> );
<span class="hljs-keyword">var</span> Notify = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Notify'</span> );
<span class="hljs-keyword">var</span> StateAttribute = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/StateAttribute'</span> );
<span class="hljs-keyword">var</span> StateSet = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/StateSet'</span> );
<span class="hljs-keyword">var</span> Texture = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Texture'</span> );
<span class="hljs-keyword">var</span> Transform = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Transform'</span> );
<span class="hljs-keyword">var</span> Uniform = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Uniform'</span> );
<span class="hljs-keyword">var</span> MACROUTILS = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Utils'</span> );
<span class="hljs-keyword">var</span> Vec3 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Vec3'</span> );
<span class="hljs-keyword">var</span> Vec4 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Vec4'</span> );
<span class="hljs-keyword">var</span> Viewport = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Viewport'</span> );
<span class="hljs-keyword">var</span> WebGLCaps = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/WebGLCaps'</span> );
<span class="hljs-keyword">var</span> ShadowReceiveAttribute = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osgShadow/ShadowReceiveAttribute'</span> );
<span class="hljs-keyword">var</span> ShadowCasterVisitor = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osgShadow/ShadowCasterVisitor'</span> );
<span class="hljs-keyword">var</span> ShadowFrustumIntersection = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osgShadow/ShadowFrustumIntersection'</span> );
<span class="hljs-keyword">var</span> ShadowCastAttribute = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osgShadow/ShadowCastAttribute'</span> );
<span class="hljs-keyword">var</span> ShadowTechnique = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osgShadow/ShadowTechnique'</span> );
<span class="hljs-keyword">var</span> ShadowTexture = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osgShadow/ShadowTexture'</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Custom camera cull callback
we customize it just to avoid to add extra ‘virtual’ function
on the shadowTecnique class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> CameraCullCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> shadowTechnique </span>) </span>{
    <span class="hljs-keyword">this</span>._shadowTechnique = shadowTechnique;
};

CameraCullCallback.prototype = {
    cull: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> node, nv </span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>see ShadowTechnique CameraCullCallback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._shadowTechnique.getShadowedScene().nodeTraverse( nv );



        <span class="hljs-keyword">var</span> cs = nv.getCurrentCullingSet();
        <span class="hljs-keyword">if</span> ( nv.getComputeNearFar() === <span class="hljs-literal">true</span> &amp;&amp; nv.getComputedFar() &gt;= nv.getComputedNear() ) {
            <span class="hljs-keyword">var</span> m = nv.getCurrentProjectionMatrix();</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Matrix.clampProjectionMatrix( m, nv.getComputedNear(), nv.getComputedFar(), nv.getNearFarRatio() );</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._shadowTechnique.getDepthRange()[ <span class="hljs-number">0</span> ] = nv.getComputedNear();
            <span class="hljs-keyword">this</span>._shadowTechnique.getDepthRange()[ <span class="hljs-number">1</span> ] = nv.getComputedFar();

            Matrix.getFrustumPlanes( m, nv.getCurrentModelViewMatrix(), cs.getFrustum().getPlanes(), <span class="hljs-literal">false</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>TODO: no far no near.
should check if we have them
should add at least a near 0 clip if not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            cs.getFrustum().setupMask( <span class="hljs-number">6</span> );
        }

        <span class="hljs-keyword">this</span>._shadowTechnique.setLightFrustum( cs.getFrustum() );
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};

<span class="hljs-comment">/**
 *  ShadowMap provides an implementation of shadow textures.
 *  @class ShadowMap
 */</span>
<span class="hljs-keyword">var</span> ShadowMap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> settings </span>) </span>{
    ShadowTechnique.call( <span class="hljs-keyword">this</span> );

    <span class="hljs-keyword">this</span>._projectionMatrix = Matrix.create();
    <span class="hljs-keyword">this</span>._viewMatrix = Matrix.create();

    <span class="hljs-keyword">this</span>._lightUp = Vec3.createAndSet( <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );

    <span class="hljs-keyword">this</span>._light = settings.light;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._cameraShadow = <span class="hljs-keyword">new</span> Camera();
    <span class="hljs-keyword">this</span>._cameraShadow.setCullCallback( <span class="hljs-keyword">new</span> CameraCullCallback( <span class="hljs-keyword">this</span> ) );
    <span class="hljs-keyword">this</span>._cameraShadow.setRenderOrder( Camera.PRE_RENDER, <span class="hljs-number">0</span> );
    <span class="hljs-keyword">this</span>._cameraShadow.setReferenceFrame( Transform.ABSOLUTE_RF );
    <span class="hljs-keyword">this</span>._cameraShadow.setClearColor( Vec4.createAndSet( <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ) );

    <span class="hljs-keyword">this</span>._texture = <span class="hljs-keyword">new</span> ShadowTexture();
    <span class="hljs-keyword">this</span>._textureUnitBase = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">this</span>._textureUnit = <span class="hljs-keyword">this</span>._textureUnitBase;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>see shadowSettings.js header for param explanations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._textureMagFilter = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">this</span>._textureMinFilter = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">this</span>._textureSize = <span class="hljs-number">256</span>;

    <span class="hljs-keyword">this</span>._receivingStateset = <span class="hljs-literal">undefined</span>;

    <span class="hljs-keyword">this</span>._casterStateSet = <span class="hljs-keyword">new</span> StateSet();
    <span class="hljs-keyword">this</span>._casterStateSet.addUniform( Uniform.createFloat1( <span class="hljs-number">0</span>, <span class="hljs-string">'exponent0'</span> ) );
    <span class="hljs-keyword">this</span>._casterStateSet.addUniform( Uniform.createFloat1( <span class="hljs-number">0</span>, <span class="hljs-string">'exponent1'</span> ) );
    <span class="hljs-keyword">this</span>._casterStateSet.addUniform( Uniform.createFloat1( <span class="hljs-number">0.005</span>, <span class="hljs-string">'bias'</span> ) );
    <span class="hljs-keyword">this</span>._casterStateSet.addUniform( Uniform.createFloat1( <span class="hljs-number">1.0</span> / <span class="hljs-keyword">this</span>._textureSize, <span class="hljs-string">'texelSize'</span> ) );
    <span class="hljs-keyword">this</span>._casterStateSet.addUniform( Uniform.createFloat2( [ <span class="hljs-keyword">this</span>._textureSize, <span class="hljs-keyword">this</span>._textureSize ], <span class="hljs-string">'RenderSize'</span> ) );</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>make sure no unintended blend happens
if casting semi-transparent (alphablend material with full opaque pixels) shadow</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._casterStateSet.setAttributeAndModes( <span class="hljs-keyword">new</span> Depth( Depth.LESS ), StateAttribute.ON | StateAttribute.OVERRIDE );
    <span class="hljs-keyword">this</span>._casterStateSet.setAttributeAndModes( <span class="hljs-keyword">new</span> BlendFunc(), StateAttribute.ON | StateAttribute.OVERRIDE );

    <span class="hljs-keyword">this</span>._shadowReceiveAttribute = <span class="hljs-keyword">new</span> ShadowReceiveAttribute( <span class="hljs-keyword">this</span>._light.getLightNumber() );
    <span class="hljs-keyword">this</span>._casterStateSet.setAttributeAndModes( <span class="hljs-keyword">this</span>._shadowReceiveAttribute, StateAttribute.ON | StateAttribute.OVERRIDE );</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>default name, overridable with shadow settings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._shadowCastShaderGeneratorName = <span class="hljs-string">'ShadowCast'</span>;


    <span class="hljs-keyword">var</span> near = <span class="hljs-number">0.001</span>;
    <span class="hljs-keyword">var</span> far = <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">this</span>._depthRange = Vec4.create();
    <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ] = near;
    <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ] = far;
    <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">2</span> ] = far - near;
    <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">3</span> ] = <span class="hljs-number">1.0</span> / ( far - near );
    <span class="hljs-keyword">this</span>._casterStateSet.addUniform( Uniform.createFloat4( <span class="hljs-keyword">this</span>._depthRange, <span class="hljs-string">'Shadow_DepthRange'</span> ) );




    <span class="hljs-keyword">this</span>._worldLightPos = Vec4.create();
    <span class="hljs-keyword">this</span>._worldLightPos[ <span class="hljs-number">3</span> ] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>._worldLightDir = Vec4.create();
    <span class="hljs-keyword">this</span>._worldLightDir[ <span class="hljs-number">3</span> ] = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">this</span>._castsShadowDrawTraversalMask = <span class="hljs-number">0xffffffff</span>;
    <span class="hljs-keyword">this</span>._castsShadowBoundsTraversalMask = <span class="hljs-number">0xffffffff</span>;


    <span class="hljs-keyword">this</span>._shaderProcessor = <span class="hljs-literal">undefined</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>tmp variables</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._tmpVec = Vec3.create();
    <span class="hljs-keyword">this</span>._tmpVecBis = Vec3.create();
    <span class="hljs-keyword">this</span>._tmpVecTercio = Vec3.create();
    <span class="hljs-keyword">this</span>._tmpMatrix = Matrix.create();

    <span class="hljs-keyword">if</span> ( settings )
        <span class="hljs-keyword">this</span>.setShadowSettings( settings );

    <span class="hljs-keyword">this</span>._computeFrustumBounds = <span class="hljs-keyword">new</span> ShadowFrustumIntersection();
    <span class="hljs-keyword">this</span>._computeBoundsVisitor = <span class="hljs-keyword">new</span> ComputeBoundsVisitor();</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Overridable Visitor so that user can override the visitor to enable disable
in its own shadowmap implementation
settings.userShadowCasterVisitor:</p>
<ul>
<li>undefined means using default</li>
<li>false means no removal visitor needed</li>
<li>otherwise must be an instance of a class inherited from shadowCaster</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> ( settings.userShadowCasterVisitor !== <span class="hljs-literal">false</span> ) {

        <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor = settings.userShadowCasterVisitor || <span class="hljs-keyword">new</span> ShadowCasterVisitor( <span class="hljs-keyword">this</span>._castsShadowTraversalMask );

    }

    <span class="hljs-keyword">this</span>._infiniteFrustum = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> shadowStateAttribute = <span class="hljs-keyword">new</span> ShadowCastAttribute( <span class="hljs-literal">false</span>, <span class="hljs-keyword">this</span>._shadowReceiveAttribute );

    <span class="hljs-keyword">this</span>._casterStateSet.setAttributeAndModes( shadowStateAttribute, StateAttribute.ON | StateAttribute.OVERRIDE );
    <span class="hljs-keyword">this</span>._casterStateSet.setShaderGeneratorName( <span class="hljs-keyword">this</span>._shadowCastShaderGeneratorName, StateAttribute.OVERRIDE | StateAttribute.ON );

};


<span class="hljs-comment">/** @lends ShadowMap.prototype */</span>
ShadowMap.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( ShadowTechnique.prototype, {

    getDepthRange: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._depthRange;
    },
    setLightFrustum: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> lf </span>) </span>{
        <span class="hljs-keyword">this</span>._lightFrustum = lf;
    },
    getCamera: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._cameraShadow;
    },

    getTexture: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._texture;
    },

    isDirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._dirty;
    },
    <span class="hljs-comment">/**
     * at which Texture unit number we start adding texture shadow
     */</span>
    setTextureUnitBase: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> unitBase </span>) </span>{
        <span class="hljs-keyword">this</span>._textureUnitBase = unitBase;
        <span class="hljs-keyword">this</span>._textureUnit = unitBase;
    },

    <span class="hljs-comment">/* Sets  shadowSettings
     */</span>
    setShadowSettings: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> shadowSettings </span>) </span>{

        <span class="hljs-keyword">if</span> ( !shadowSettings )
            <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">this</span>._light = shadowSettings.light;
        <span class="hljs-keyword">this</span>._shadowCastShaderGeneratorName = shadowSettings.getShadowCastShaderGeneratorName();

        <span class="hljs-keyword">this</span>.setCastsShadowDrawTraversalMask( shadowSettings.castsShadowDrawTraversalMask );
        <span class="hljs-keyword">this</span>.setCastsShadowBoundsTraversalMask( shadowSettings.castsShadowBoundsTraversalMask );

        <span class="hljs-keyword">this</span>.setLight( <span class="hljs-keyword">this</span>._light );
        <span class="hljs-keyword">this</span>.setTextureSize( shadowSettings.textureSize );
        <span class="hljs-keyword">this</span>.setTexturePrecision( shadowSettings.textureType );

        <span class="hljs-keyword">this</span>.setFakePCF( shadowSettings.fakePCF );
        <span class="hljs-keyword">this</span>.setRotateOffset( shadowSettings.rotateOffset );
        <span class="hljs-keyword">this</span>.setKernelSizePCF( shadowSettings.kernelSizePCF );
        <span class="hljs-keyword">this</span>.setAlgorithm( shadowSettings.algorithm );
        <span class="hljs-keyword">this</span>.setBias( shadowSettings.bias );
        <span class="hljs-keyword">this</span>.setExponent0( shadowSettings.exponent );
        <span class="hljs-keyword">this</span>.setExponent1( shadowSettings.exponent1 );
        <span class="hljs-keyword">this</span>.setEpsilonVSM( shadowSettings.epsilonVSM );


    },

    setCastsShadowDrawTraversalMask: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> mask </span>) </span>{
        <span class="hljs-keyword">this</span>._castsShadowDrawTraversalMask = mask;
    },

    getCastsShadowDrawTraversalMask: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._castsDrawShadowTraversalMask;
    },

    setCastsShadowBoundsTraversalMask: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> mask </span>) </span>{
        <span class="hljs-keyword">this</span>._castsShadowBoundsTraversalMask = mask;
    },

    getCastsShadowBoundsTraversalMask: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._castsShadowBoundsTraversalMask;
    },


    getBias: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getBias();
    },

    setBias: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setBias( value );
        <span class="hljs-keyword">this</span>._casterStateSet.getUniformList()[ <span class="hljs-string">'bias'</span> ].getUniform().setFloat( value );
    },

    getExponent0: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getExponent0();
    },

    setExponent0: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setExponent0( value );
        <span class="hljs-keyword">this</span>._casterStateSet.getUniformList()[ <span class="hljs-string">'exponent0'</span> ].getUniform().setFloat( value );
    },

    getExponent1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getExponent1();
    },

    setExponent1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setExponent1( value );
        <span class="hljs-keyword">this</span>._casterStateSet.getUniformList()[ <span class="hljs-string">'exponent1'</span> ].getUniform().setFloat( value );
    },

    getEpsilonVSM: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getEpsilonVSM();
    },

    setEpsilonVSM: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setEpsilonVSM( value );
    },

    getKernelSizePCF: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getKernelSizePCF();
    },

    setKernelSizePCF: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setKernelSizePCF( value );
    },

    getFakePCF: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getFakePCF();
    },

    setFakePCF: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getFakePCF() !== value ) {
            <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setFakePCF( value );
            <span class="hljs-keyword">this</span>.setTextureFiltering();
        }
    },

    getRotateOffset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getRotateOffset();
    },

    setRotateOffset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getRotateOffset() !== value ) {
            <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setRotateOffset( value );
        }
    },

    setShadowedScene: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> shadowedScene </span>) </span>{
        ShadowTechnique.prototype.setShadowedScene.call( <span class="hljs-keyword">this</span>, shadowedScene );
        <span class="hljs-keyword">this</span>._receivingStateset = <span class="hljs-keyword">this</span>._shadowedScene.getReceivingStateSet();
        <span class="hljs-keyword">this</span>.dirty();
    },

    checkLightNumber: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> lightNumber = <span class="hljs-keyword">this</span>._light.getLightNumber();</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>if light number changed we need to remove cleanly
attributes from receiveStateSet
it’s because it use a typemember like light attribute
so the number if very important to keep State clean</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getLightNumber() !== lightNumber ) {
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._receivingStateset.getAttribute( <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getTypeMember() ) === <span class="hljs-keyword">this</span>._shadowReceiveAttribute )
                <span class="hljs-keyword">this</span>._receivingStateset.removeAttribute( <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getTypeMember() );
        }

        <span class="hljs-comment">/*develblock:start*/</span>
        Notify.assert( <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getTypeMember() === <span class="hljs-keyword">this</span>._shadowReceiveAttribute.attributeType + lightNumber, <span class="hljs-string">'TypeMember isnt reflecting light number'</span> + <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getTypeMember() + <span class="hljs-string">' !== '</span> + <span class="hljs-keyword">this</span>._shadowReceiveAttribute.attributeType + lightNumber );
        <span class="hljs-comment">/*develblock:end*/</span>


        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._texture &amp;&amp; <span class="hljs-keyword">this</span>._texture.getLightUnit() !== lightNumber ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>remove this._texture, but not if it’s not this._texture</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._receivingStateset.getTextureAttribute( <span class="hljs-keyword">this</span>._textureUnit, <span class="hljs-keyword">this</span>._texture.getTypeMember() ) === <span class="hljs-keyword">this</span>._texture )
                <span class="hljs-keyword">this</span>._receivingStateset.removeTextureAttribute( <span class="hljs-keyword">this</span>._textureUnit, <span class="hljs-keyword">this</span>._texture.getTypeMember() );
        }

    },

    <span class="hljs-comment">/** initialize the ShadowedScene and local cached data structures.*/</span>
    init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>._shadowedScene ) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">this</span>._filledOnce = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">this</span>.checkLightNumber();

        <span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>._cameraShadow ) {
            <span class="hljs-keyword">this</span>._cameraShadow = <span class="hljs-keyword">new</span> Camera();
            <span class="hljs-keyword">this</span>._cameraShadow.setCullCallback( <span class="hljs-keyword">new</span> CameraCullCallback( <span class="hljs-keyword">this</span> ) );
            <span class="hljs-keyword">this</span>._cameraShadow.setRenderOrder( Camera.PRE_RENDER, <span class="hljs-number">0</span> );
            <span class="hljs-keyword">this</span>._cameraShadow.setReferenceFrame( Transform.ABSOLUTE_RF );
            <span class="hljs-keyword">this</span>._cameraShadow.setClearColor( Vec4.createAndSet( <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ) );
        }

        <span class="hljs-keyword">this</span>.initTexture();

        <span class="hljs-keyword">var</span> lightNumber = <span class="hljs-keyword">this</span>._light.getLightNumber();
        <span class="hljs-keyword">this</span>._textureUnit = <span class="hljs-keyword">this</span>._textureUnitBase + lightNumber;
        <span class="hljs-keyword">this</span>._cameraShadow.setName( <span class="hljs-string">'light_shadow_camera'</span> + <span class="hljs-keyword">this</span>._light.getName() );

        <span class="hljs-keyword">this</span>._texture.setLightUnit( lightNumber );
        <span class="hljs-keyword">this</span>._texture.setName( <span class="hljs-string">'ShadowTexture'</span> + <span class="hljs-keyword">this</span>._textureUnit );

        <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setLightNumber( lightNumber );</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Idea is to make sure the null texture is “binded” to all shadow casting scene
so we override all existing texture bind in the scene, preventing any texture bind.
When user implements alpha mask casting, they use PROTECTED to prevent OVERRIDE to remove their alpha mask texture needed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> fullOverride = StateAttribute.OVERRIDE | StateAttribute.ON;


        <span class="hljs-keyword">this</span>._receivingStateset.setAttributeAndModes( <span class="hljs-keyword">this</span>._shadowReceiveAttribute, fullOverride );</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>prevent unnecessary texture bindings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._preventTextureBindingDuringShadowCasting();</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Mandatory: prevent binding shadow textures themselves
( ShadowedScene StateSet is applied  just above in StateSet hierarchy)
that would mean undefined values as it would be read/write access…
So we force it against Texture.null binding done just above (PROTECTED)
and Prevent any under hierarchy bind with OVERRIDE
must be done AFTER the prevent binding.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._casterStateSet.setTextureAttributeAndModes( <span class="hljs-keyword">this</span>._textureUnit, Texture.textureNull, StateAttribute.PROTECTED );</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>add shadow texture to the receivers
should make sure somehow that
alpha blender transparent receiver doesn’t use it
compiler wise at least</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._receivingStateset.setTextureAttributeAndModes( <span class="hljs-keyword">this</span>._textureUnit, <span class="hljs-keyword">this</span>._texture, fullOverride );

        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Make sure we don’t bind texture and thus make GPU work for nothing
as shadow casting just output Depth ( no color )
os we set a null texture and OVERRIDE StateAttribute flag
only case you want to use a texture is
alpha masked material, then you have StateAttribute to ‘PROTECTED’</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _preventTextureBindingDuringShadowCasting: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>prevent unnecessary texture bindings on all texture unit
TODO: actually get the real max texture unit from webglCaps</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> shouldGetMaxTextureUnits = WebGLCaps.instance().getWebGLParameter( <span class="hljs-string">'MAX_TEXTURE_IMAGE_UNITS'</span> );
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; shouldGetMaxTextureUnits; k++ ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>bind  null texture which OSGJS will not bind,
effectively preventing any other texture bind
just not touching texture unit state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._casterStateSet.setTextureAttributeAndModes( k, Texture.textureNull, StateAttribute.OVERRIDE | StateAttribute.ON );
        }

    },
    valid: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>checks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    },

    updateShadowTechnique: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> <span class="hljs-comment">/*nv*/</span></span>) </span>{

        <span class="hljs-keyword">var</span> camera = <span class="hljs-keyword">this</span>._cameraShadow;
        <span class="hljs-keyword">var</span> texture = <span class="hljs-keyword">this</span>._texture;

        <span class="hljs-keyword">if</span> ( camera &amp;&amp; texture ) {

            <span class="hljs-keyword">var</span> vp = camera.getViewport();
            <span class="hljs-keyword">if</span> ( !vp ) {
                vp = <span class="hljs-keyword">new</span> Viewport();
                camera.setViewport( vp );
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>if texture size changed update the camera rtt params</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( vp.width() !== texture.getWidth() ||
                vp.height() !== texture.getHeight() ) {

                camera.detachAll();

                camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture );
                camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );

                camera.getViewport().setViewport( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, texture.getWidth(), texture.getHeight() );
            }
        }
    },

    updateShadowTechnic: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> <span class="hljs-comment">/*nv*/</span></span>) </span>{
        Notify.log( <span class="hljs-string">'ShadowMap.updateShadowTechnic() is deprecated, use updateShadowTechnique instead'</span> );
        <span class="hljs-keyword">this</span>.updateShadowTechnique();
    },

    setTextureFiltering: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">var</span> textureType, texFilterMin, texFilterMag;
        <span class="hljs-keyword">var</span> texType = <span class="hljs-keyword">this</span>.getTexturePrecision();
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._texture ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>see shadowSettings.js header</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">switch</span> ( <span class="hljs-keyword">this</span>.getAlgorithm() ) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'ESM'</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'VSM'</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'EVSM'</span>:
                texFilterMin = Texture.LINEAR;
                texFilterMag = Texture.LINEAR;
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'PCF'</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'NONE'</span>:
                <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.getFakePCF() ) {
                    texFilterMin = Texture.LINEAR;
                    texFilterMag = Texture.LINEAR;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>// TODO try anisotropy with better biaspcf
texFilterMin = Texture.LINEAR_MIPMAP_LINEAR;
texFilterMag = Texture.LINEAR_MIPMAP_LINEAR;
this._texture.setMaxAnisotropy( 16 );</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

                } <span class="hljs-keyword">else</span> {
                    texFilterMin = Texture.NEAREST;
                    texFilterMag = Texture.NEAREST;
                }
                <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">switch</span> ( texType ) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'HALF_FLOAT'</span>:
                textureType = Texture.HALF_FLOAT;
                texFilterMin = Texture.NEAREST;
                texFilterMag = Texture.NEAREST;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'HALF_FLOAT_LINEAR'</span>:
                textureType = Texture.HALF_FLOAT;
                texFilterMin = Texture.LINEAR;
                texFilterMag = Texture.LINEAR;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'FLOAT'</span>:
                textureType = Texture.FLOAT;
                texFilterMin = Texture.NEAREST;
                texFilterMag = Texture.NEAREST;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'FLOAT_LINEAR'</span>:
                textureType = Texture.FLOAT;
                texFilterMin = Texture.LINEAR;
                texFilterMag = Texture.LINEAR;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'UNSIGNED_BYTE'</span>:
                textureType = Texture.UNSIGNED_BYTE;
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-keyword">this</span>._texture.setInternalFormatType( textureType );
        <span class="hljs-keyword">this</span>._texture.setMinFilter( texFilterMin );
        <span class="hljs-keyword">this</span>._texture.setMagFilter( texFilterMag );
        <span class="hljs-keyword">this</span>._textureMagFilter = texFilterMag;
        <span class="hljs-keyword">this</span>._textureMinFilter = texFilterMin;

    },</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>internal texture allocation
handle any change like resize, filter param, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    initTexture: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>._dirty ) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>._texture ) {
            <span class="hljs-keyword">this</span>._texture = <span class="hljs-keyword">new</span> ShadowTexture();
            <span class="hljs-keyword">this</span>._textureUnit = <span class="hljs-keyword">this</span>._textureUnitBase;
        }


        <span class="hljs-keyword">var</span> textureFormat;</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>luminance Float format ?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        textureFormat = Texture.RGBA;

        <span class="hljs-keyword">this</span>._texture.setTextureSize( <span class="hljs-keyword">this</span>._textureSize, <span class="hljs-keyword">this</span>._textureSize );
        <span class="hljs-keyword">this</span>.setTextureFiltering();
        <span class="hljs-keyword">this</span>._texture.setInternalFormat( textureFormat );

        <span class="hljs-keyword">this</span>._texture.setWrapS( Texture.CLAMP_TO_EDGE );
        <span class="hljs-keyword">this</span>._texture.setWrapT( Texture.CLAMP_TO_EDGE );

        <span class="hljs-keyword">this</span>._texture.dirty();

    },
    setTexturePrecision: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> format </span>) </span>{
        <span class="hljs-keyword">if</span> ( format === <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getPrecision() ) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setPrecision( format );
        <span class="hljs-keyword">this</span>.dirty();
    },

    getTexturePrecision: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getPrecision();
    },

    setTextureSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> mapSize </span>) </span>{

        <span class="hljs-keyword">if</span> ( mapSize === <span class="hljs-keyword">this</span>._textureSize ) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">this</span>._textureSize = mapSize;
        <span class="hljs-keyword">this</span>.dirty();
    },

    setAlgorithm: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> algo </span>) </span>{

        <span class="hljs-keyword">if</span> ( algo === <span class="hljs-keyword">this</span>.getAlgorithm() ) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">this</span>._shadowReceiveAttribute.setAlgorithm( algo );
        <span class="hljs-keyword">this</span>.dirty();
    },

    getAlgorithm: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getAlgorithm();
    },

    setLight: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> light </span>) </span>{

        <span class="hljs-keyword">if</span> ( !light || light === <span class="hljs-keyword">this</span>._light )
            <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">this</span>._light = light;
        <span class="hljs-keyword">this</span>.dirty();
    },

    getUp: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> dir </span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>avoid dir/up wrong angle breaking computation</p>

            </div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>compute a up vector ensuring avoiding parallel vectors
also might reverting to it once got the change here done once
Vec3.createAndSet( 0.0, 0.0, 1.0 );</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs( Vec3.dot( <span class="hljs-keyword">this</span>._lightUp, dir ) ) &gt;= <span class="hljs-number">1.0</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>another camera up
Vec3.createAndSet( 1.0, 0.0, 0.0 );</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._lightUp[ <span class="hljs-number">0</span> ] === <span class="hljs-number">1.0</span> ) {
                <span class="hljs-keyword">this</span>._lightUp[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0.0</span>;
                <span class="hljs-keyword">this</span>._lightUp[ <span class="hljs-number">1</span> ] = <span class="hljs-number">1.0</span>;
                <span class="hljs-keyword">this</span>._lightUp[ <span class="hljs-number">2</span> ] = <span class="hljs-number">0.0</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>._lightUp[ <span class="hljs-number">0</span> ] = <span class="hljs-number">1.0</span>;
                <span class="hljs-keyword">this</span>._lightUp[ <span class="hljs-number">1</span> ] = <span class="hljs-number">0.0</span>;
                <span class="hljs-keyword">this</span>._lightUp[ <span class="hljs-number">2</span> ] = <span class="hljs-number">0.0</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._lightUp;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>makes sure we don’t have incorrect near/far
or we actually have to render something.
Empty or Bad Frustums
No objects, handle it gracefully</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    nearFarBounding: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">var</span> zNear = <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ];
        <span class="hljs-keyword">var</span> zFar = <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ];

        <span class="hljs-keyword">var</span> epsilon = ShadowMap.EPSILON;
        <span class="hljs-keyword">if</span> ( zFar &lt; zNear - epsilon ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>early out</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._emptyCasterScene = <span class="hljs-literal">true</span>;
            zFar = <span class="hljs-number">1</span>;
            zNear = epsilon;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( zNear &lt; epsilon ) {
            zNear = epsilon;
        }

        <span class="hljs-keyword">var</span> nearFarRatio = <span class="hljs-number">0.005</span>;
        <span class="hljs-keyword">if</span> ( zNear &lt; zFar * nearFarRatio ) {
            zNear = zFar * nearFarRatio;
        }

        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ] = zNear;
        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ] = zFar;
    },

    makePerspectiveFromBoundingBox: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> bbox, fov, eyePos, eyeDir, view, projection </span>) </span>{
        <span class="hljs-keyword">var</span> center = bbox.center( <span class="hljs-keyword">this</span>._tmpVec );
        <span class="hljs-keyword">var</span> radius = bbox.radius();
        <span class="hljs-keyword">var</span> epsilon = ShadowMap.EPSILON;
        <span class="hljs-keyword">var</span> zNear = epsilon;
        <span class="hljs-keyword">var</span> zFar = <span class="hljs-number">1.0</span>;

        Vec3.copy( eyeDir, <span class="hljs-keyword">this</span>._tmpVecBis );
        Vec3.neg( <span class="hljs-keyword">this</span>._tmpVecBis, <span class="hljs-keyword">this</span>._tmpVecBis );
        Vec3.normalize( <span class="hljs-keyword">this</span>._tmpVecBis, <span class="hljs-keyword">this</span>._tmpVecBis );</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>light Near Plane Equation
E = eyeDir + d</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> d = Vec3.dot( eyePos, <span class="hljs-keyword">this</span>._tmpVecBis );</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>then distance to center point of sphere
perpendicular to lightdir</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> distance = Vec3.dot( center, <span class="hljs-keyword">this</span>._tmpVecBis ) + d;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>inside or not have unfluence
on using radius for fov</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( distance &lt; -radius ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>won’t render anything the object  is behind..</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._emptyCasterScene = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( distance &lt;= <span class="hljs-number">0.0</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>shhh.. we’re inside !
sphere center is behind</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            zNear = epsilon;
            zFar = distance + radius;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( distance &lt; radius ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>shhh.. we’re inside !
sphere center is in front</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            zNear = epsilon;
            zFar = distance + radius;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p> Sphere totally in front
long distance runner
we must make a nicer zNear here!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            zNear = distance - radius;
            zFar = distance + radius;
        }

        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ] = zNear;
        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ] = zFar;
        <span class="hljs-keyword">this</span>.nearFarBounding();</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>positional light: spot, point, area
 fov &lt; 180.0
statically defined by spot, only needs zNear zFar estimates</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> fovRadius = <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ] * <span class="hljs-built_in">Math</span>.tan( fov * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180.0</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>if scene radius is smaller than fov on scene
Tighten and enhance precision</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        fovRadius = fovRadius &gt; radius ? radius : fovRadius;

        <span class="hljs-keyword">var</span> ymax = fovRadius;
        <span class="hljs-keyword">var</span> ymin = -ymax;

        <span class="hljs-keyword">var</span> xmax = fovRadius;
        <span class="hljs-keyword">var</span> xmin = -xmax;

        <span class="hljs-keyword">var</span> up = <span class="hljs-keyword">this</span>.getUp( eyeDir );

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._infiniteFrustum ) {
            Matrix.makeFrustumInfinite( xmin, xmax, ymin, ymax, <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ], <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ], projection );
        } <span class="hljs-keyword">else</span> {
            Matrix.makeFrustum( xmin, xmax, ymin, ymax, <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ], <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ], projection );
        }

        Matrix.makeLookFromDirection( eyePos, eyeDir, up, view );
    },

    makeOrthoFromBoundingBox: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> bbox, eyeDir, view, projection </span>) </span>{

        <span class="hljs-keyword">var</span> center = bbox.center( <span class="hljs-keyword">this</span>._tmpVecTercio );

        <span class="hljs-keyword">var</span> radius = bbox.radius();
        <span class="hljs-keyword">var</span> diameter = radius + radius;

        <span class="hljs-keyword">var</span> zNear = <span class="hljs-number">0.0001</span>;
        <span class="hljs-keyword">var</span> zFar = diameter + <span class="hljs-number">0.0001</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>compute eye Pos from a inverted lightDir Ray shot from center of bbox
firs make a RAY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> ray = <span class="hljs-keyword">this</span>._tmpVecBis;
        Vec3.mult( eyeDir, -diameter, ray );</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>then move the eye to the that far pos following the ray</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> eyePos = <span class="hljs-keyword">this</span>._tmpVec;
        Vec3.add( center, ray, eyePos );

        zNear = radius;
        zFar += radius;

        <span class="hljs-keyword">var</span> zNearRatio = <span class="hljs-number">0.001</span>;
        <span class="hljs-keyword">if</span> ( zNear &lt; zFar * zNearRatio ) {
            zNear = zFar * zNearRatio;
        }

        <span class="hljs-keyword">var</span> up = <span class="hljs-keyword">this</span>.getUp( eyeDir );
        Matrix.makeLookFromDirection( eyePos, eyeDir, up, view );

        <span class="hljs-keyword">var</span> right, top;
        top = radius;
        right = top;
        Matrix.makeOrtho( -right, right, -top, top, zNear, zFar, projection );

        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ] = zNear;
        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ] = zFar;

    },
    <span class="hljs-comment">/*
     * Sync camera and light vision so that
     * shadow map render using a camera whom
     * settings come from the light
     * and the scene being shadowed
     */</span>
    aimShadowCastingCamera: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> cullVisitor, frustumBound </span>) </span>{

        <span class="hljs-keyword">var</span> light = <span class="hljs-keyword">this</span>._light;

        <span class="hljs-keyword">if</span> ( !light ) {
            <span class="hljs-keyword">this</span>._emptyCasterScene = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> camera = <span class="hljs-keyword">this</span>._cameraShadow;

        <span class="hljs-keyword">var</span> worldLightPos = <span class="hljs-keyword">this</span>._worldLightPos;
        <span class="hljs-keyword">var</span> worldLightDir = <span class="hljs-keyword">this</span>._worldLightDir;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>make sure it’s not modified outside our computations
camera matrix can be modified by cullvisitor afterwards…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Matrix.copy( camera.getProjectionMatrix(), <span class="hljs-keyword">this</span>._projectionMatrix );
        Matrix.copy( camera.getViewMatrix(), <span class="hljs-keyword">this</span>._viewMatrix );
        <span class="hljs-keyword">var</span> projection = <span class="hljs-keyword">this</span>._projectionMatrix;
        <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">this</span>._viewMatrix;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>inject camera world matrix.
from light current world/pos and camera eye pos.
inject camera world matrix.
from light current world/pos
NEED same camera eye pos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> positionedAttribute = cullVisitor.getCurrentRenderBin().getPositionedAttribute();

        <span class="hljs-keyword">var</span> lightMatrix;
        positionedAttribute = positionedAttribute.find( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> element </span>) </span>{
            <span class="hljs-keyword">if</span> ( element.length &gt; <span class="hljs-number">0</span> &amp;&amp; element[ <span class="hljs-number">1</span> ] === light ) {
                lightMatrix = element[ <span class="hljs-number">0</span> ];
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } );
        <span class="hljs-keyword">if</span> ( lightMatrix === <span class="hljs-literal">undefined</span> ) {
            Notify.warn( <span class="hljs-string">'light isnt inside children of shadowedScene Node'</span> );
            <span class="hljs-keyword">this</span>._emptyCasterScene = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> eyeToWorld = <span class="hljs-keyword">this</span>._tmpMatrix;
        Matrix.inverse( cullVisitor.getCurrentModelViewMatrix(), eyeToWorld );</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p> light pos &amp; lightTarget in World Space</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( light.getPosition()[ <span class="hljs-number">3</span> ] !== <span class="hljs-number">0.0</span> &amp;&amp; light.getSpotCutoff() &lt; <span class="hljs-number">180</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>TODO: check when spot light is camera attached?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            Matrix.mult( eyeToWorld, lightMatrix, <span class="hljs-keyword">this</span>._tmpMatrix );
            <span class="hljs-keyword">var</span> worldMatrix = <span class="hljs-keyword">this</span>._tmpMatrix;</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>same code as light spot shader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            Matrix.transformVec3( worldMatrix, light.getPosition(), worldLightPos );
            worldMatrix[ <span class="hljs-number">12</span> ] = <span class="hljs-number">0</span>;
            worldMatrix[ <span class="hljs-number">13</span> ] = <span class="hljs-number">0</span>;
            worldMatrix[ <span class="hljs-number">14</span> ] = <span class="hljs-number">0</span>;
            Matrix.inverse( worldMatrix, worldMatrix );
            Matrix.transpose( worldMatrix, worldMatrix );</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>not a directionnal light, compute the world light dir</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            Vec3.copy( light.getDirection(), worldLightDir );
            Matrix.transformVec4( worldMatrix, worldLightDir, worldLightDir );
            Vec3.normalize( worldLightDir, worldLightDir );</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>and compute a perspective frustum</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>.makePerspectiveFromBoundingBox( frustumBound, light.getSpotCutoff(), worldLightPos, worldLightDir, view, projection );
        } <span class="hljs-keyword">else</span> {
            Matrix.transformVec4( lightMatrix, light.getPosition(), worldLightPos );
            Matrix.transformVec4( eyeToWorld, worldLightPos, worldLightPos );</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>same code as light sun shader
lightpos is a light dir
so we now have to normalize
since the transform to world above</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            Vec3.mult( worldLightPos, <span class="hljs-number">-1.0</span>, worldLightPos );
            Vec3.normalize( worldLightPos, worldLightPos );
            <span class="hljs-keyword">this</span>.makeOrthoFromBoundingBox( frustumBound, worldLightPos, view, projection );
        }

        Matrix.copy( <span class="hljs-keyword">this</span>._projectionMatrix, camera.getProjectionMatrix() );
        Matrix.copy( <span class="hljs-keyword">this</span>._viewMatrix, camera.getViewMatrix() );</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>set values now</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.setShadowUniformsDepthValue();

    },</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>culling is done,
now try for a the tightest frustum
possible for shadowcasting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    frameShadowCastingFrustum: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> cullVisitor </span>) </span>{

        <span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>._infiniteFrustum ) {
            <span class="hljs-keyword">this</span>.nearFarBounding();
            Matrix.clampProjectionMatrix( <span class="hljs-keyword">this</span>._projectionMatrix, <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ], <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ], cullVisitor.getNearFarRatio(), <span class="hljs-keyword">this</span>._depthRange );
            <span class="hljs-keyword">this</span>.setShadowUniformsDepthValue();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>overwrite any cullvisitor wrongness</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> camera = <span class="hljs-keyword">this</span>._cameraShadow;
        Matrix.copy( <span class="hljs-keyword">this</span>._projectionMatrix, camera.getProjectionMatrix() );
        Matrix.copy( <span class="hljs-keyword">this</span>._viewMatrix, camera.getViewMatrix() );

    },

    setShadowUniformsDepthValue: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">this</span>.nearFarBounding();</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>set values now</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">2</span> ] = <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ] - <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ];
        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">3</span> ] = <span class="hljs-number">1.0</span> / ( <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">2</span> ] );

        <span class="hljs-keyword">var</span> castUniforms = <span class="hljs-keyword">this</span>._casterStateSet.getUniformList();
        castUniforms[ <span class="hljs-string">'Shadow_DepthRange'</span> ].getUniform().setVec4( <span class="hljs-keyword">this</span>._depthRange );

        <span class="hljs-keyword">this</span>._texture.setViewMatrix( <span class="hljs-keyword">this</span>._viewMatrix );
        <span class="hljs-keyword">this</span>._texture.setProjectionMatrix( <span class="hljs-keyword">this</span>._projectionMatrix );
        <span class="hljs-keyword">this</span>._texture.setDepthRange( <span class="hljs-keyword">this</span>._depthRange );

    },

    noDraw: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">1</span> ] = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">2</span> ] = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">this</span>._depthRange[ <span class="hljs-number">3</span> ] = <span class="hljs-number">0.0</span>;

        <span class="hljs-keyword">var</span> castUniforms = <span class="hljs-keyword">this</span>._casterStateSet.getUniformList();

        castUniforms[ <span class="hljs-string">'Shadow_DepthRange'</span> ].getUniform().setVec4( <span class="hljs-keyword">this</span>._depthRange );
        <span class="hljs-keyword">this</span>._texture.setDepthRange( <span class="hljs-keyword">this</span>._depthRange );

        <span class="hljs-keyword">var</span> camera = <span class="hljs-keyword">this</span>._cameraShadow;</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>make sure it’s not modified outside our computations
camera matrix can be modified by cullvisitor afterwards…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Matrix.copy( camera.getProjectionMatrix(), <span class="hljs-keyword">this</span>._projectionMatrix );
        Matrix.copy( camera.getViewMatrix(), <span class="hljs-keyword">this</span>._viewMatrix );

        <span class="hljs-keyword">this</span>._texture.setViewMatrix( <span class="hljs-keyword">this</span>._viewMatrix );
        <span class="hljs-keyword">this</span>._texture.setProjectionMatrix( <span class="hljs-keyword">this</span>._projectionMatrix );

        <span class="hljs-keyword">this</span>._filledOnce = <span class="hljs-literal">true</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Defines the frustum from light param.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    cullShadowCasting: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> cullVisitor </span>) </span>{

        <span class="hljs-keyword">var</span> bbox;

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor ) {

            <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor.setNoCastMask( ~( <span class="hljs-keyword">this</span>._castsShadowBoundsTraversalMask | <span class="hljs-keyword">this</span>._castsShadowDrawTraversalMask ) );
            <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor.reset();
            <span class="hljs-keyword">this</span>.getShadowedScene().accept( <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor );

        }

        <span class="hljs-keyword">this</span>._computeBoundsVisitor.setTraversalMask( <span class="hljs-keyword">this</span>._castsShadowBoundsTraversalMask );
        <span class="hljs-keyword">this</span>._computeBoundsVisitor.reset();
        <span class="hljs-keyword">this</span>.getShadowedScene().accept( <span class="hljs-keyword">this</span>._computeBoundsVisitor );
        bbox = <span class="hljs-keyword">this</span>._computeBoundsVisitor.getBoundingBox();

        <span class="hljs-keyword">if</span> ( !bbox.valid() ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>nothing to draw Early out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>.noDraw();

            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>remove our flags changes on any bitmask
not to break things</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor.restore();

            }

            <span class="hljs-keyword">return</span>;

        }</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>HERE we get the shadowedScene Current World Matrix
to get any world transform ABOVE the shadowedScene</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> worldMatrix = cullVisitor.getCurrentModelWorldMatrix();</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>it does fuck up the results.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Matrix.transformBoundingBox( worldMatrix, bbox, bbox );

        <span class="hljs-keyword">this</span>._emptyCasterScene = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.aimShadowCastingCamera( cullVisitor, bbox );

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._emptyCasterScene ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>nothing to draw Early out.
console.log( ‘shadow early OUT’ );</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>.noDraw();

            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>remove our flags changes on any bitmask
not to break things</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor.restore();

            }

            <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>get renderer to make the cull program
record the traversal mask on entry so we can reapply it later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> traversalMask = cullVisitor.getTraversalMask();

        cullVisitor.setTraversalMask( <span class="hljs-keyword">this</span>._castsShadowDrawTraversalMask );</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>cast geometries into depth shadow map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        cullVisitor.pushStateSet( <span class="hljs-keyword">this</span>._casterStateSet );

        <span class="hljs-keyword">this</span>._cameraShadow.setEnableFrustumCulling( <span class="hljs-literal">true</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>enabling this makes for strange projection fuck up
(as in clamped too tight projection)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> needNearFar = <span class="hljs-keyword">this</span>._castsShadowDrawTraversalMask === <span class="hljs-keyword">this</span>._castsShadowBoundsTraversalMask;
        <span class="hljs-keyword">this</span>._cameraShadow.setComputeNearFar( needNearFar );</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>do RTT from the camera traversal mimicking light pos/orient</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._cameraShadow.accept( cullVisitor );</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Here culling is done, we do have near/far.
and cull/non-culled info
if we wanted a tighter frustum.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( needNearFar ) {
            <span class="hljs-keyword">this</span>.frameShadowCastingFrustum( cullVisitor );
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>enabling this makes for strange projection fuck up
(as in clamped too tight projection)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._cameraShadow.setComputeNearFar( <span class="hljs-literal">false</span> );

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>remove our flags changes on any bitmask
not to break things</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._removeNodesNeverCastingVisitor.restore();

        }

        cullVisitor.popStateSet();</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>reapply the original traversal mask</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        cullVisitor.setTraversalMask( traversalMask );
        <span class="hljs-keyword">this</span>._filledOnce = <span class="hljs-literal">true</span>;
    },

    cleanReceivingStateSet: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._receivingStateset ) {

            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._texture ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>remove this._texture, but not if it’s not this._texture</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._receivingStateset.getTextureAttribute( <span class="hljs-keyword">this</span>._textureUnit, <span class="hljs-keyword">this</span>._texture.getTypeMember() ) === <span class="hljs-keyword">this</span>._texture )
                    <span class="hljs-keyword">this</span>._receivingStateset.removeTextureAttribute( <span class="hljs-keyword">this</span>._textureUnit, <span class="hljs-keyword">this</span>._texture.getTypeMember() );
            }

            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._receivingStateset.getAttribute( <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getTypeMember() ) === <span class="hljs-keyword">this</span>._shadowReceiveAttribute )
                <span class="hljs-keyword">this</span>._receivingStateset.removeAttribute( <span class="hljs-keyword">this</span>._shadowReceiveAttribute.getTypeMember() );
        }

    },
    cleanSceneGraph: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>well release a lot more things when it works</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._cameraShadow = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">this</span>._filledOnce = <span class="hljs-literal">false</span>;


        <span class="hljs-keyword">this</span>.cleanReceivingStateSet();</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>TODO: need state
this._texture.releaseGLObjects();
this._shadowReceiveAttribute = undefined;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._texture = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">this</span>._shadowedScene = <span class="hljs-literal">undefined</span>;
    }

} ), <span class="hljs-string">'osgShadow'</span>, <span class="hljs-string">'ShadowMap'</span> );

ShadowMap.EPSILON = <span class="hljs-number">5e-3</span>;

MACROUTILS.setTypeID( ShadowMap );

<span class="hljs-built_in">module</span>.exports = ShadowMap;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
