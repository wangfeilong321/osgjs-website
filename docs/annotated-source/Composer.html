<!DOCTYPE html>

<html>
<head>
  <title>Composer.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="OSG.html">
                OSG.js
              </a>
            
              
              <a class="source" href="BillboardAttribute.html">
                BillboardAttribute.js
              </a>
            
              
              <a class="source" href="BlendColor.html">
                BlendColor.js
              </a>
            
              
              <a class="source" href="BlendFunc.html">
                BlendFunc.js
              </a>
            
              
              <a class="source" href="BoundingBox.html">
                BoundingBox.js
              </a>
            
              
              <a class="source" href="BoundingSphere.html">
                BoundingSphere.js
              </a>
            
              
              <a class="source" href="BufferArray.html">
                BufferArray.js
              </a>
            
              
              <a class="source" href="BufferArrayProxy.html">
                BufferArrayProxy.js
              </a>
            
              
              <a class="source" href="Camera.html">
                Camera.js
              </a>
            
              
              <a class="source" href="ColorMask.html">
                ColorMask.js
              </a>
            
              
              <a class="source" href="ComputeBoundsVisitor.html">
                ComputeBoundsVisitor.js
              </a>
            
              
              <a class="source" href="ComputeMatrixFromNodePath.html">
                ComputeMatrixFromNodePath.js
              </a>
            
              
              <a class="source" href="CullFace.html">
                CullFace.js
              </a>
            
              
              <a class="source" href="CullSettings.html">
                CullSettings.js
              </a>
            
              
              <a class="source" href="CullStack.html">
                CullStack.js
              </a>
            
              
              <a class="source" href="CullVisitor.html">
                CullVisitor.js
              </a>
            
              
              <a class="source" href="CullingSet.html">
                CullingSet.js
              </a>
            
              
              <a class="source" href="Depth.html">
                Depth.js
              </a>
            
              
              <a class="source" href="DrawArrayLengths.html">
                DrawArrayLengths.js
              </a>
            
              
              <a class="source" href="DrawArrays.html">
                DrawArrays.js
              </a>
            
              
              <a class="source" href="DrawElements.html">
                DrawElements.js
              </a>
            
              
              <a class="source" href="EllipsoidModel.html">
                EllipsoidModel.js
              </a>
            
              
              <a class="source" href="FrameBufferObject.html">
                FrameBufferObject.js
              </a>
            
              
              <a class="source" href="FrameStamp.html">
                FrameStamp.js
              </a>
            
              
              <a class="source" href="GLObject.html">
                GLObject.js
              </a>
            
              
              <a class="source" href="Geometry.html">
                Geometry.js
              </a>
            
              
              <a class="source" href="Image.html">
                Image.js
              </a>
            
              
              <a class="source" href="ImageStream.html">
                ImageStream.js
              </a>
            
              
              <a class="source" href="KdTree.html">
                KdTree.js
              </a>
            
              
              <a class="source" href="KdTreeBuilder.html">
                KdTreeBuilder.js
              </a>
            
              
              <a class="source" href="KdTreeRayIntersector.html">
                KdTreeRayIntersector.js
              </a>
            
              
              <a class="source" href="KdTreeSphereIntersector.html">
                KdTreeSphereIntersector.js
              </a>
            
              
              <a class="source" href="Light.html">
                Light.js
              </a>
            
              
              <a class="source" href="LightSource.html">
                LightSource.js
              </a>
            
              
              <a class="source" href="LineWidth.html">
                LineWidth.js
              </a>
            
              
              <a class="source" href="Lod.html">
                Lod.js
              </a>
            
              
              <a class="source" href="Map.html">
                Map.js
              </a>
            
              
              <a class="source" href="Material.html">
                Material.js
              </a>
            
              
              <a class="source" href="Math.html">
                Math.js
              </a>
            
              
              <a class="source" href="Matrix.html">
                Matrix.js
              </a>
            
              
              <a class="source" href="MatrixMemoryPool.html">
                MatrixMemoryPool.js
              </a>
            
              
              <a class="source" href="MatrixTransform.html">
                MatrixTransform.js
              </a>
            
              
              <a class="source" href="Node.html">
                Node.js
              </a>
            
              
              <a class="source" href="NodeVisitor.html">
                NodeVisitor.js
              </a>
            
              
              <a class="source" href="Notify.html">
                Notify.js
              </a>
            
              
              <a class="source" href="Object.html">
                Object.js
              </a>
            
              
              <a class="source" href="Options.html">
                Options.js
              </a>
            
              
              <a class="source" href="PagedLOD.html">
                PagedLOD.js
              </a>
            
              
              <a class="source" href="Plane.html">
                Plane.js
              </a>
            
              
              <a class="source" href="Polytope.html">
                Polytope.js
              </a>
            
              
              <a class="source" href="PrimitiveFunctor.html">
                PrimitiveFunctor.js
              </a>
            
              
              <a class="source" href="PrimitiveSet.html">
                PrimitiveSet.js
              </a>
            
              
              <a class="source" href="Program.html">
                Program.js
              </a>
            
              
              <a class="source" href="Projection.html">
                Projection.js
              </a>
            
              
              <a class="source" href="Quat.html">
                Quat.js
              </a>
            
              
              <a class="source" href="RenderBin.html">
                RenderBin.js
              </a>
            
              
              <a class="source" href="RenderLeaf.html">
                RenderLeaf.js
              </a>
            
              
              <a class="source" href="RenderStage.html">
                RenderStage.js
              </a>
            
              
              <a class="source" href="Shader.html">
                Shader.js
              </a>
            
              
              <a class="source" href="Shape.html">
                Shape.js
              </a>
            
              
              <a class="source" href="Stack.html">
                Stack.js
              </a>
            
              
              <a class="source" href="State.html">
                State.js
              </a>
            
              
              <a class="source" href="StateAttribute.html">
                StateAttribute.js
              </a>
            
              
              <a class="source" href="StateGraph.html">
                StateGraph.js
              </a>
            
              
              <a class="source" href="StateSet.html">
                StateSet.js
              </a>
            
              
              <a class="source" href="Texture.html">
                Texture.js
              </a>
            
              
              <a class="source" href="TextureCubeMap.html">
                TextureCubeMap.js
              </a>
            
              
              <a class="source" href="TextureManager.html">
                TextureManager.js
              </a>
            
              
              <a class="source" href="Timer.html">
                Timer.js
              </a>
            
              
              <a class="source" href="Transform.html">
                Transform.js
              </a>
            
              
              <a class="source" href="TransformEnums.html">
                TransformEnums.js
              </a>
            
              
              <a class="source" href="TriangleIndexFunctor.html">
                TriangleIndexFunctor.js
              </a>
            
              
              <a class="source" href="Uniform.html">
                Uniform.js
              </a>
            
              
              <a class="source" href="UpdateVisitor.html">
                UpdateVisitor.js
              </a>
            
              
              <a class="source" href="Utils.html">
                Utils.js
              </a>
            
              
              <a class="source" href="Vec2.html">
                Vec2.js
              </a>
            
              
              <a class="source" href="Vec3.html">
                Vec3.js
              </a>
            
              
              <a class="source" href="Vec4.html">
                Vec4.js
              </a>
            
              
              <a class="source" href="Viewport.html">
                Viewport.js
              </a>
            
              
              <a class="source" href="WebGLCaps.html">
                WebGLCaps.js
              </a>
            
              
              <a class="source" href="osg.html">
                osg.js
              </a>
            
              
              <a class="source" href="Animation.html">
                Animation.js
              </a>
            
              
              <a class="source" href="AnimationUpdateCallback.html">
                AnimationUpdateCallback.js
              </a>
            
              
              <a class="source" href="BasicAnimationManager.html">
                BasicAnimationManager.js
              </a>
            
              
              <a class="source" href="Bone.html">
                Bone.js
              </a>
            
              
              <a class="source" href="Channel.html">
                Channel.js
              </a>
            
              
              <a class="source" href="CollectAnimationUpdateCallbackVisitor.html">
                CollectAnimationUpdateCallbackVisitor.js
              </a>
            
              
              <a class="source" href="CollectBoneVisitor.html">
                CollectBoneVisitor.js
              </a>
            
              
              <a class="source" href="Easing.html">
                Easing.js
              </a>
            
              
              <a class="source" href="FindNearestParentSkeleton.html">
                FindNearestParentSkeleton.js
              </a>
            
              
              <a class="source" href="Interpolator.html">
                Interpolator.js
              </a>
            
              
              <a class="source" href="MorphAttribute.html">
                MorphAttribute.js
              </a>
            
              
              <a class="source" href="MorphGeometry.html">
                MorphGeometry.js
              </a>
            
              
              <a class="source" href="RigGeometry.html">
                RigGeometry.js
              </a>
            
              
              <a class="source" href="RigTransformHardware.html">
                RigTransformHardware.js
              </a>
            
              
              <a class="source" href="Skeleton.html">
                Skeleton.js
              </a>
            
              
              <a class="source" href="SkinningAttribute.html">
                SkinningAttribute.js
              </a>
            
              
              <a class="source" href="StackedMatrix.html">
                StackedMatrix.js
              </a>
            
              
              <a class="source" href="StackedQuaternion.html">
                StackedQuaternion.js
              </a>
            
              
              <a class="source" href="StackedRotateAxis.html">
                StackedRotateAxis.js
              </a>
            
              
              <a class="source" href="StackedScale.html">
                StackedScale.js
              </a>
            
              
              <a class="source" href="StackedTranslate.html">
                StackedTranslate.js
              </a>
            
              
              <a class="source" href="Target.html">
                Target.js
              </a>
            
              
              <a class="source" href="UpdateBone.html">
                UpdateBone.js
              </a>
            
              
              <a class="source" href="UpdateMatrixTransform.html">
                UpdateMatrixTransform.js
              </a>
            
              
              <a class="source" href="UpdateMorph.html">
                UpdateMorph.js
              </a>
            
              
              <a class="source" href="UpdateRigGeometry.html">
                UpdateRigGeometry.js
              </a>
            
              
              <a class="source" href="UpdateSkeleton.html">
                UpdateSkeleton.js
              </a>
            
              
              <a class="source" href="channelType.html">
                channelType.js
              </a>
            
              
              <a class="source" href="osgAnimation.html">
                osgAnimation.js
              </a>
            
              
              <a class="source" href="DatabasePager.html">
                DatabasePager.js
              </a>
            
              
              <a class="source" href="Input.html">
                Input.js
              </a>
            
              
              <a class="source" href="Options.html">
                Options.js
              </a>
            
              
              <a class="source" href="ReaderParser.html">
                ReaderParser.js
              </a>
            
              
              <a class="source" href="osgDB.html">
                osgDB.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulator.html">
                FirstPersonManipulator.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulatorDeviceOrientationController.html">
                FirstPersonManipulatorDeviceOrientationController.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulatorHammerController.html">
                FirstPersonManipulatorHammerController.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulatorStandardMouseKeyboardController.html">
                FirstPersonManipulatorStandardMouseKeyboardController.js
              </a>
            
              
              <a class="source" href="FirstPersonManipulatorWebVRController.html">
                FirstPersonManipulatorWebVRController.js
              </a>
            
              
              <a class="source" href="Manipulator.html">
                Manipulator.js
              </a>
            
              
              <a class="source" href="OrbitManipulator.html">
                OrbitManipulator.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorDeviceOrientationController.html">
                OrbitManipulatorDeviceOrientationController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorEnums.html">
                OrbitManipulatorEnums.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorGamePadController.html">
                OrbitManipulatorGamePadController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorHammerController.html">
                OrbitManipulatorHammerController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorLeapMotionController.html">
                OrbitManipulatorLeapMotionController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorStandardMouseKeyboardController.html">
                OrbitManipulatorStandardMouseKeyboardController.js
              </a>
            
              
              <a class="source" href="OrbitManipulatorWebVRController.html">
                OrbitManipulatorWebVRController.js
              </a>
            
              
              <a class="source" href="SwitchManipulator.html">
                SwitchManipulator.js
              </a>
            
              
              <a class="source" href="osgGA.html">
                osgGA.js
              </a>
            
              
              <a class="source" href="osgNameSpace.html">
                osgNameSpace.js
              </a>
            
              
              <a class="source" href="Compiler.html">
                Compiler.js
              </a>
            
              
              <a class="source" href="ShaderGenerator.html">
                ShaderGenerator.js
              </a>
            
              
              <a class="source" href="ShaderGeneratorProxy.html">
                ShaderGeneratorProxy.js
              </a>
            
              
              <a class="source" href="ShaderProcessor.html">
                ShaderProcessor.js
              </a>
            
              
              <a class="source" href="node.html">
                node.js
              </a>
            
              
              <a class="source" href="Node.html">
                Node.js
              </a>
            
              
              <a class="source" href="data.html">
                data.js
              </a>
            
              
              <a class="source" href="functions.html">
                functions.js
              </a>
            
              
              <a class="source" href="lights.html">
                lights.js
              </a>
            
              
              <a class="source" href="morph.html">
                morph.js
              </a>
            
              
              <a class="source" href="operations.html">
                operations.js
              </a>
            
              
              <a class="source" href="shadows.html">
                shadows.js
              </a>
            
              
              <a class="source" href="skinning.html">
                skinning.js
              </a>
            
              
              <a class="source" href="textures.html">
                textures.js
              </a>
            
              
              <a class="source" href="nodeFactory.html">
                nodeFactory.js
              </a>
            
              
              <a class="source" href="osgShader.html">
                osgShader.js
              </a>
            
              
              <a class="source" href="shaderLib.html">
                shaderLib.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
              
              <a class="source" href="ShadowCastAttribute.html">
                ShadowCastAttribute.js
              </a>
            
              
              <a class="source" href="ShadowCastCompiler.html">
                ShadowCastCompiler.js
              </a>
            
              
              <a class="source" href="ShadowCastShaderGenerator.html">
                ShadowCastShaderGenerator.js
              </a>
            
              
              <a class="source" href="ShadowCasterVisitor.html">
                ShadowCasterVisitor.js
              </a>
            
              
              <a class="source" href="ShadowFrustumIntersection.html">
                ShadowFrustumIntersection.js
              </a>
            
              
              <a class="source" href="ShadowMap.html">
                ShadowMap.js
              </a>
            
              
              <a class="source" href="ShadowReceiveAttribute.html">
                ShadowReceiveAttribute.js
              </a>
            
              
              <a class="source" href="ShadowSettings.html">
                ShadowSettings.js
              </a>
            
              
              <a class="source" href="ShadowTechnique.html">
                ShadowTechnique.js
              </a>
            
              
              <a class="source" href="ShadowTexture.html">
                ShadowTexture.js
              </a>
            
              
              <a class="source" href="ShadowedScene.html">
                ShadowedScene.js
              </a>
            
              
              <a class="source" href="osgShadow.html">
                osgShadow.js
              </a>
            
              
              <a class="source" href="shaderLib.html">
                shaderLib.js
              </a>
            
              
              <a class="source" href="Text.html">
                Text.js
              </a>
            
              
              <a class="source" href="osgText.html">
                osgText.js
              </a>
            
              
              <a class="source" href="Composer.html">
                Composer.js
              </a>
            
              
              <a class="source" href="DisplayGeometryVisitor.html">
                DisplayGeometryVisitor.js
              </a>
            
              
              <a class="source" href="DisplayGraph.html">
                DisplayGraph.js
              </a>
            
              
              <a class="source" href="DisplayGraphNode.html">
                DisplayGraphNode.js
              </a>
            
              
              <a class="source" href="DisplayGraphRenderer.html">
                DisplayGraphRenderer.js
              </a>
            
              
              <a class="source" href="DisplayNormalVisitor.html">
                DisplayNormalVisitor.js
              </a>
            
              
              <a class="source" href="GizmoGeometry.html">
                GizmoGeometry.js
              </a>
            
              
              <a class="source" href="IntersectionVisitor.html">
                IntersectionVisitor.js
              </a>
            
              
              <a class="source" href="LineSegmentIntersector.html">
                LineSegmentIntersector.js
              </a>
            
              
              <a class="source" href="NodeGizmo.html">
                NodeGizmo.js
              </a>
            
              
              <a class="source" href="ParameterVisitor.html">
                ParameterVisitor.js
              </a>
            
              
              <a class="source" href="PolytopeIntersector.html">
                PolytopeIntersector.js
              </a>
            
              
              <a class="source" href="PolytopePrimitiveIntersector.html">
                PolytopePrimitiveIntersector.js
              </a>
            
              
              <a class="source" href="SphereIntersector.html">
                SphereIntersector.js
              </a>
            
              
              <a class="source" href="TangentSpaceGenerator.html">
                TangentSpaceGenerator.js
              </a>
            
              
              <a class="source" href="TriangleIntersector.html">
                TriangleIntersector.js
              </a>
            
              
              <a class="source" href="TriangleSphereIntersector.html">
                TriangleSphereIntersector.js
              </a>
            
              
              <a class="source" href="WebVR.html">
                WebVR.js
              </a>
            
              
              <a class="source" href="WebVRCustom.html">
                WebVRCustom.js
              </a>
            
              
              <a class="source" href="osgPool.html">
                osgPool.js
              </a>
            
              
              <a class="source" href="osgUtil.html">
                osgUtil.js
              </a>
            
              
              <a class="source" href="Renderer.html">
                Renderer.js
              </a>
            
              
              <a class="source" href="Scene.html">
                Scene.js
              </a>
            
              
              <a class="source" href="View.html">
                View.js
              </a>
            
              
              <a class="source" href="Viewer.html">
                Viewer.js
              </a>
            
              
              <a class="source" href="createStats.html">
                createStats.js
              </a>
            
              
              <a class="source" href="DeviceOrientation.html">
                DeviceOrientation.js
              </a>
            
              
              <a class="source" href="EventProxy.html">
                EventProxy.js
              </a>
            
              
              <a class="source" href="GamePad.html">
                GamePad.js
              </a>
            
              
              <a class="source" href="Hammer.html">
                Hammer.js
              </a>
            
              
              <a class="source" href="LeapMotion.html">
                LeapMotion.js
              </a>
            
              
              <a class="source" href="StandardMouseKeyboard.html">
                StandardMouseKeyboard.js
              </a>
            
              
              <a class="source" href="WebVR.html">
                WebVR.js
              </a>
            
              
              <a class="source" href="osgViewer.html">
                osgViewer.js
              </a>
            
              
              <a class="source" href="webgl-debug.html">
                webgl-debug.js
              </a>
            
              
              <a class="source" href="webgl-utils.html">
                webgl-utils.js
              </a>
            
              
              <a class="source" href="osgWrappers.html">
                osgWrappers.js
              </a>
            
              
              <a class="source" href="osg.html">
                osg.js
              </a>
            
              
              <a class="source" href="osgAnimation.html">
                osgAnimation.js
              </a>
            
              
              <a class="source" href="osgText.html">
                osgText.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>Composer.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-meta">'use strict'</span>;
<span class="hljs-keyword">var</span> Notify = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Notify'</span> );
<span class="hljs-keyword">var</span> MACROUTILS = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Utils'</span> );
<span class="hljs-keyword">var</span> Node = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Node'</span> );
<span class="hljs-keyword">var</span> CullFace = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/CullFace'</span> );
<span class="hljs-keyword">var</span> Depth = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Depth'</span> );
<span class="hljs-keyword">var</span> Texture = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Texture'</span> );
<span class="hljs-keyword">var</span> Camera = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Camera'</span> );
<span class="hljs-keyword">var</span> FrameBufferObject = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/FrameBufferObject'</span> );
<span class="hljs-keyword">var</span> Viewport = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Viewport'</span> );
<span class="hljs-keyword">var</span> Matrix = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Matrix'</span> );
<span class="hljs-keyword">var</span> Uniform = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Uniform'</span> );
<span class="hljs-keyword">var</span> StateSet = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/StateSet'</span> );
<span class="hljs-keyword">var</span> Program = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Program'</span> );
<span class="hljs-keyword">var</span> Shader = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Shader'</span> );
<span class="hljs-keyword">var</span> Shape = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Shape'</span> );
<span class="hljs-keyword">var</span> TransformEnums = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/TransformEnums'</span> );
<span class="hljs-keyword">var</span> Vec2 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Vec2'</span> );
<span class="hljs-keyword">var</span> Vec3 = <span class="hljs-built_in">require</span>( <span class="hljs-string">'osg/Vec3'</span> );


<span class="hljs-comment">/*
 Composer is an helper to create post fx. The idea is to push one or more textures into a pipe of shader filter.

 how to use it:

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>example how to blur a texture and render it to screen</p>

            </div>
            
            <div class="content"><div class='highlight'><pre> <span class="hljs-keyword">var</span> myTexture; <span class="hljs-comment">// imagine it's your texture you want to process</span>
 <span class="hljs-keyword">var</span> composer = <span class="hljs-keyword">new</span> Composer();
 composer.addPass(<span class="hljs-keyword">new</span> Composer.Filter.InputTexture(myTexture));
 composer.addPass(<span class="hljs-keyword">new</span> Composer.Filter.HBlur(<span class="hljs-number">5</span>));
 composer.addPass(<span class="hljs-keyword">new</span> Composer.Filter.VBlur(<span class="hljs-number">5</span>));
 composer.renderToScreen(<span class="hljs-number">1200</span>, <span class="hljs-number">900</span>);
 composer.build(); <span class="hljs-comment">// if you dont build manually it will be done in the scenegraph while upading</span>
 rootnode.addChild(composer);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>now you can imagine to some process and use the result as input texture for a geometry</p>

            </div>
            
            <div class="content"><div class='highlight'><pre> var myTexture; // imagine it's your texture you want to process
 var myResultTexture = new Texture(); // imagine it's your texture you want to process
 myResultTexture.setTextureSize(1200,900);
 var composer = new Composer();
 composer.addPass(new Composer.Filter.InputTexture(myTexture));
 composer.addPass(new Composer.Filter.HBlur(5));
 composer.addPass(new Composer.Filter.VBlur(5), resultTexture);

 myGeometry.getStateSet().setTextureAttributeAndModes(0, resultTexture);
 rootnode.addChild(composer);

 */

var Composer = function () {
    Node.call( this );
    this._stack = [];
    this._renderToScreen = false;
    this._dirty = false;

    this._textureRTT = [];
    this._cameraRTT = [];

    var UpdateCallback = function () {

    };
    UpdateCallback.prototype = {
        update: function ( node /*, nv */ ) {
            if ( node.isDirty() ) {
                node.build();
            }
            return true;
        }
    };
    this.setUpdateCallback( new UpdateCallback() );</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>disable unecessarry drawing/states/check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.getOrCreateStateSet().setAttributeAndModes( <span class="hljs-keyword">new</span> Depth( <span class="hljs-string">'DISABLE'</span> ) );
    <span class="hljs-keyword">this</span>.getOrCreateStateSet().setAttributeAndModes( <span class="hljs-keyword">new</span> CullFace( <span class="hljs-string">'BACK'</span> ) );
};

Composer.prototype = MACROUTILS.objectInherit( Node.prototype, {
    dirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-keyword">this</span>._stack.length; i &lt; l; i++ ) {
            <span class="hljs-keyword">this</span>._stack[ i ].filter.dirty();
        }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>addPass support different signature
addPass(filter) -&gt; the filter will be done on a texture of the same size than the previous pass
addPass(filter, textureWidth, textureHeight) -&gt; the filter will be done on a texture width and height
addPass(filter, texture) -&gt; the filter will be done on the giver texture using its width and height</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addPass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> filter, arg0, arg1 </span>) </span>{

        <span class="hljs-keyword">var</span> newPass = {};
        newPass.filter = filter;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>when arg0 is a texture
arg1 is the target, can be TEXTURE_2D ( by default ) or
a cubemape’s face like TEXTURE_CUBE_MAP_POSITIVE_X, …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( arg0 <span class="hljs-keyword">instanceof</span> Texture ) {
            newPass.texture = arg0;
            newPass.textureTarget = arg1 || Texture.TEXTURE_2D;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( arg0 !== <span class="hljs-literal">undefined</span> &amp;&amp; arg1 !== <span class="hljs-literal">undefined</span> ) {
            newPass.width = <span class="hljs-built_in">Math</span>.floor( arg0 );
            newPass.height = <span class="hljs-built_in">Math</span>.floor( arg1 );
        }

        <span class="hljs-keyword">this</span>._stack.push( newPass );
        <span class="hljs-keyword">return</span> newPass.filter;
    },
    renderToScreen: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> w, h </span>) </span>{
        <span class="hljs-keyword">this</span>._renderToScreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>._renderToScreenWidth = w;
        <span class="hljs-keyword">this</span>._renderToScreenHeight = h;
    },
    getResultTexture: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._resultTexture;
    },
    isDirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-keyword">this</span>._stack.length; i &lt; l; i++ ) {
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._stack[ i ].filter.isDirty() ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    },

    <span class="hljs-comment">/*develblock:start*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>debug only check for specific bad condition:
in webgl 1.0 you cannot read and write on the same texture
so you shouldn’t bind a FOB texture as input and output</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    debugCheckRttNotReadWrite: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> textureResult, stateSet </span>) </span>{

        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>, lt = stateSet.getNumTextureAttributeLists(); k &lt; lt; k++ ) {
            <span class="hljs-keyword">var</span> textureBinded = stateSet.getTextureAttribute( k, <span class="hljs-string">'Texture'</span> );
            Notify.assert( textureResult !== textureBinded, <span class="hljs-string">'Composer: write/read at the same time on a texture is undefined behavior'</span> );

        }
    },
    <span class="hljs-comment">/*develblock:end*/</span>

    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>keep some references
TODO: use for reuse/cache/invalidation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self._textureRTT = [];
        self._cameraRTT = [];


        <span class="hljs-keyword">this</span>.removeChildren();
        <span class="hljs-keyword">var</span> lastTextureResult;

        <span class="hljs-keyword">this</span>._stack.forEach( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> element, i, array </span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>update filter internal due to user change on filter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( element.filter.isDirty() ) {
                element.filter.build();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>this filter need a special setup that composer build cannot do</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( element.filter.interConnectFilters ) {
                lastTextureResult = element.filter.interConnectFilters( self, i, array );</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>goto next filter directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">var</span> stateSet = element.filter.getStateSet();
            <span class="hljs-keyword">var</span> w, h;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>compute filter render texture size</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( element.texture !== <span class="hljs-literal">undefined</span> ) {

                w = element.texture.getWidth();
                h = element.texture.getHeight();

            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( element.width !== <span class="hljs-literal">undefined</span> &amp;&amp; element.height !== <span class="hljs-literal">undefined</span> ) {

                w = element.width;
                h = element.height;

            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>get width from Texture0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">var</span> inputTexture = stateSet.getTextureAttribute( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture'</span> );
                <span class="hljs-keyword">if</span> ( inputTexture === <span class="hljs-literal">undefined</span> ) {
                    Notify.warn( <span class="hljs-string">'Composer can\'t find any information to setup texture output size'</span> );
                }
                w = inputTexture.getWidth();
                h = inputTexture.getHeight();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>is it the last filter and we want to render to screen ?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> lastFilterRenderToScreen = ( i === array.length - <span class="hljs-number">1</span> &amp;&amp;
                self._renderToScreen === <span class="hljs-literal">true</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>check if we have something to do
else we will just translate stateset to the next filter
this part exist to manage the Composer.Filter.InputTexture that setup the first texture unit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( !lastFilterRenderToScreen ) {
                <span class="hljs-keyword">if</span> ( stateSet.getAttribute( <span class="hljs-string">'Program'</span> ) === <span class="hljs-literal">undefined</span> ) {
                    array[ i + <span class="hljs-number">1</span> ].filter.getStateSet().setTextureAttributeAndModes( <span class="hljs-number">0</span>, stateSet.getTextureAttribute( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture'</span> ) );
                    <span class="hljs-keyword">return</span>;
                }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>build the filter into a Camera and a StateSet</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> camera = <span class="hljs-keyword">new</span> Camera();
            self._cameraRTT.push( camera );
            camera.setStateSet( stateSet );


            <span class="hljs-keyword">var</span> textureResult;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>check if we want to render on screen</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( lastFilterRenderToScreen === <span class="hljs-literal">true</span> ) {
                w = self._renderToScreenWidth;
                h = self._renderToScreenHeight;
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Or in a offscreen Framebuffer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                camera.setRenderOrder( Camera.PRE_RENDER, <span class="hljs-number">0</span> );
                textureResult = element.texture;
                <span class="hljs-keyword">var</span> textureTarget = element.textureTarget;</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>if no user provided render target texture, create one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> ( textureResult === <span class="hljs-literal">undefined</span> ) {
                    textureResult = <span class="hljs-keyword">new</span> Texture();
                    textureResult.setName( <span class="hljs-string">'composer Rtt '</span> + element.filter.getFragmentName() );
                    textureResult.setTextureSize( w, h );
                    textureTarget = Texture.TEXTURE_2D;
                    self._textureRTT.push( textureResult );
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Attach the render texture target as FBO
Note: node depth attachment because we’re in 2D</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, textureResult, textureTarget );
            }

            <span class="hljs-keyword">var</span> vp = <span class="hljs-keyword">new</span> Viewport( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w, h );
            camera.setReferenceFrame( TransformEnums.ABSOLUTE_RF );
            camera.setViewport( vp );</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>FIXME: not really useful, but osgjs keep pushing projection matrix
and maybe some old code still use it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            Matrix.makeOrtho( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">5</span>, camera.getProjectionMatrix() );

            <span class="hljs-keyword">var</span> quad = Shape.createTexturedFullScreenFakeQuadGeometry();

            <span class="hljs-keyword">if</span> ( element.filter.buildGeometry )
                quad = element.filter.buildGeometry( quad );

            quad.setName( <span class="hljs-string">'composer layer'</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>if rendering into texture framebuffer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( textureResult ) {

                <span class="hljs-comment">/*develblock:start*/</span>
                self.debugCheckRttNotReadWrite( textureResult, stateSet );
                <span class="hljs-comment">/*develblock:end*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>assign the result texture to the next stateset</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> ( i + <span class="hljs-number">1</span> &lt; array.length ) {
                    array[ i + <span class="hljs-number">1</span> ].filter.getStateSet().setTextureAttributeAndModes( <span class="hljs-number">0</span>, textureResult );
                }

            }
            lastTextureResult = textureResult;


            camera.addChild( quad );
            element.filter.getStateSet().addUniform( Uniform.createFloat2( Vec2.createAndSet( w, h ), <span class="hljs-string">'RenderSize'</span> ) );</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Optimization, no need to clear,
unless we know we’ll have transparent parts
which is a special case rather than the default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            camera.setClearMask( <span class="hljs-number">0</span> );


            camera.setName( <span class="hljs-string">'Composer Pass'</span> + i );</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>add to composer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.addChild( camera );
        } );</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>reference to the resulting texture
undefined if rendering directly to screen</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._resultTexture = lastTextureResult;
    }
} );

Composer.Filter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._stateSet = <span class="hljs-keyword">new</span> StateSet();
    <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'FilterOSGJS'</span>;
    <span class="hljs-keyword">this</span>._vertexName = <span class="hljs-string">''</span>;
};

Composer.Filter.prototype = {
    setFragmentName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> fname </span>) </span>{
        <span class="hljs-keyword">this</span>._fragmentName = fname;
    },
    getFragmentName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._fragmentName;
    },
    setVertexName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> vname </span>) </span>{
        <span class="hljs-keyword">this</span>._vertexName = vname;
    },
    getVertexName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._vertexName;
    },
    getDefineFragmentName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'\n#define SHADER_NAME '</span> + <span class="hljs-keyword">this</span>._fragmentName + <span class="hljs-string">'\n'</span>;
    },
    getDefineVertexName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'\n#define SHADER_NAME '</span> + ( <span class="hljs-keyword">this</span>._vertexName || <span class="hljs-keyword">this</span>._fragmentName ) + <span class="hljs-string">'\n'</span>;
    },
    getStateSet: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._stateSet;
    },
    getOrCreateStateSet: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._stateSet;
    },
    dirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">true</span>;
    },
    isDirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._dirty;
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>default means you do use the special optimized full screen triangle
dubbed fakeFullscreenQuad
no need of modelView, projection, nor texcoord</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Composer.Filter.defaultVertexShader = [
    <span class="hljs-string">'attribute vec3 Vertex;'</span>,
    <span class="hljs-string">'varying vec2 FragTexCoord0;'</span>,
    <span class="hljs-string">'void main(void) {'</span>,
    <span class="hljs-string">'  gl_Position = vec4(Vertex*2.0 - 1.0,1.0);'</span>,
    <span class="hljs-string">'  FragTexCoord0 = Vertex.xy;'</span>,
    <span class="hljs-string">'}'</span>,
    <span class="hljs-string">''</span>
].join( <span class="hljs-string">'\n'</span> );
Composer.Filter.defaultFragmentShaderHeader = [
    <span class="hljs-string">'#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp float;\n #else\n precision mediump float;\n#endif'</span>,
    <span class="hljs-string">'varying vec2 FragTexCoord0;'</span>,
    <span class="hljs-string">'uniform vec2 RenderSize;'</span>,
    <span class="hljs-string">'uniform sampler2D Texture0;'</span>,
    <span class="hljs-string">''</span>
].join( <span class="hljs-string">'\n'</span> );

Composer.Filter.shaderUtils = [
    <span class="hljs-string">'vec4 packFloatTo4x8(in float v) {'</span>,
    <span class="hljs-string">'vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;'</span>,
    <span class="hljs-string">'enc = fract(enc);'</span>,
    <span class="hljs-string">'enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);'</span>,
    <span class="hljs-string">'return enc;'</span>,
    <span class="hljs-string">'}'</span>,

    <span class="hljs-string">' '</span>,
    <span class="hljs-string">'vec4 pack2FloatTo4x8(in vec2 val) {'</span>,
    <span class="hljs-string">' const vec2 bitSh = vec2(256.0, 1.0);'</span>,
    <span class="hljs-string">' const vec2 bitMsk = vec2(0.0, 1.0/256.0);'</span>,
    <span class="hljs-string">' vec2 res1 = fract(val.x * bitSh);'</span>,
    <span class="hljs-string">' res1 -= res1.xx * bitMsk;'</span>,
    <span class="hljs-string">' vec2 res2 = fract(val.y * bitSh);'</span>,
    <span class="hljs-string">' res2 -= res2.xx * bitMsk;'</span>,
    <span class="hljs-string">' return vec4(res1.x,res1.y,res2.x,res2.y);'</span>,
    <span class="hljs-string">'}'</span>,
    <span class="hljs-string">' '</span>,
    <span class="hljs-string">'float unpack4x8ToFloat( vec4 rgba ) {'</span>,
    <span class="hljs-string">' return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );'</span>,
    <span class="hljs-string">'}'</span>,
    <span class="hljs-string">' '</span>,
    <span class="hljs-string">'vec2 unpack4x8To2Float(in vec4 val) {'</span>,
    <span class="hljs-string">' const vec2 unshift = vec2(1.0/256.0, 1.0);'</span>,
    <span class="hljs-string">' return vec2(dot(val.xy, unshift), dot(val.zw, unshift));'</span>,
    <span class="hljs-string">'}'</span>,

    <span class="hljs-string">'vec2 encodeNormal (vec3 n)'</span>,
    <span class="hljs-string">'{'</span>,
    <span class="hljs-string">'    float f = sqrt(8.0*n.z+8.0);'</span>,
    <span class="hljs-string">'    return n.xy / f + 0.5;'</span>,
    <span class="hljs-string">'}'</span>,

    <span class="hljs-string">'vec3 decodeNormal (vec2 enc)'</span>,
    <span class="hljs-string">'{'</span>,
    <span class="hljs-string">'    vec2 fenc = enc*4.0-2.0;'</span>,
    <span class="hljs-string">'    float f = dot(fenc,fenc);'</span>,
    <span class="hljs-string">'    float g = sqrt(1.0-f/4.0);'</span>,
    <span class="hljs-string">'    vec3 n;'</span>,
    <span class="hljs-string">'    n.xy = fenc*g;'</span>,
    <span class="hljs-string">'    n.z = 1.0-f/2.0;'</span>,
    <span class="hljs-string">'    return n;'</span>,
    <span class="hljs-string">'}'</span>,
    <span class="hljs-string">''</span>
].join( <span class="hljs-string">'\n'</span> );

Composer.Filter.Helper = {
    pascalCache: [
        [ <span class="hljs-number">1</span> ]
    ],
    getOrCreatePascalCoefficients: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> kernelSize </span>) </span>{
        kernelSize = kernelSize === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">5</span> : <span class="hljs-built_in">Math</span>.min( kernelSize, <span class="hljs-number">128</span> );
        <span class="hljs-keyword">var</span> cache = Composer.Filter.Helper.pascalCache;
        <span class="hljs-keyword">if</span> ( cache[ kernelSize ] )
            <span class="hljs-keyword">return</span> cache[ kernelSize ];
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> j = cache.length - <span class="hljs-number">1</span>; j &lt; kernelSize; j++ ) {
            <span class="hljs-keyword">var</span> currentRow = cache[ j ];
            <span class="hljs-keyword">var</span> currentRowSize = currentRow.length;

            <span class="hljs-keyword">var</span> nextRow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( currentRowSize );
            nextRow[ <span class="hljs-number">0</span> ] = <span class="hljs-number">1.0</span>;
            nextRow[ currentRowSize ] = <span class="hljs-number">1.0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>unnormalized pascal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> sum = j === cache.length - <span class="hljs-number">1</span> ? <span class="hljs-built_in">Math</span>.pow( <span class="hljs-number">2</span>, j ) : <span class="hljs-number">1.0</span>;
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> p = <span class="hljs-number">0</span>; p &lt; currentRowSize - <span class="hljs-number">1</span>; p++ )
                nextRow[ p + <span class="hljs-number">1</span> ] = ( currentRow[ p ] + currentRow[ p + <span class="hljs-number">1</span> ] ) * sum;</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>normalized array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            sum = <span class="hljs-built_in">Math</span>.pow( <span class="hljs-number">2</span>, j + <span class="hljs-number">1</span> );
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; currentRowSize + <span class="hljs-number">1</span>; k++ )
                nextRow[ k ] /= sum;
            cache.push( nextRow );
        }
        <span class="hljs-keyword">return</span> cache[ kernelSize ];
    }
};

Composer.Filter.Custom = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> fragmentShader, uniforms </span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );
    <span class="hljs-keyword">this</span>._fragmentShader = fragmentShader;
    <span class="hljs-keyword">this</span>._uniforms = uniforms;
    <span class="hljs-keyword">this</span>._vertexShader = Composer.Filter.defaultVertexShader;
};

Composer.Filter.Custom.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
    setFragmentShader: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> f </span>) </span>{
        <span class="hljs-keyword">this</span>._fragmentShader = f;
    },
    setVertexShader: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> v </span>) </span>{
        <span class="hljs-keyword">this</span>._vertexShader = v;
    },
    autoBindFragmentUniformStateSet: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> stateSet, fragmentShader, uniforms </span>) </span>{

        <span class="hljs-keyword">var</span> unitIndex = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>TODO: check if not a better place Utils
and reuse (we already do this in shader)
At least DEFINE the regexp somewhere somehow</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> r = fragmentShader.match( <span class="hljs-regexp">/uniform\s+\w+\s+\w+/g</span> );
        <span class="hljs-keyword">if</span> ( !r ) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = r.length; i &lt; l; i++ ) {

            <span class="hljs-keyword">var</span> match = r[ i ].match( <span class="hljs-regexp">/uniform\s+(\w+)\s+(\w+)/</span> );
            <span class="hljs-keyword">var</span> uniformType = match[ <span class="hljs-number">1</span> ];
            <span class="hljs-keyword">var</span> uniformName = match[ <span class="hljs-number">2</span> ];
            <span class="hljs-keyword">var</span> uniform;

            <span class="hljs-keyword">if</span> ( !uniforms[ uniformName ] ) <span class="hljs-keyword">continue</span>;

            <span class="hljs-keyword">var</span> uniformValue = uniforms[ uniformName ];

            <span class="hljs-keyword">if</span> ( uniformType.search( <span class="hljs-string">'sampler'</span> ) !== <span class="hljs-number">-1</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>STRONG IMPLICIT LINKING HERE:
Texture Unit Linked directly to declaration order in fragment Shader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                stateSet.setTextureAttributeAndModes( unitIndex, uniformValue );
                uniform = Uniform.createInt1( unitIndex, uniformName );
                unitIndex++;
                stateSet.addUniform( uniform );

            } <span class="hljs-keyword">else</span> {

                <span class="hljs-keyword">if</span> ( Uniform.isUniform( uniformValue ) ) {
                    uniform = uniformValue;
                } <span class="hljs-keyword">else</span> {
                    uniform = Uniform[ uniformType ]( uniforms[ uniformName ], uniformName );
                }
                stateSet.addUniform( uniform );

            }

        }
    },
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">this</span>._program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, <span class="hljs-keyword">this</span>._vertexShader + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, <span class="hljs-keyword">this</span>._fragmentShader + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._uniforms ) {
            <span class="hljs-keyword">this</span>.autoBindFragmentUniformStateSet( <span class="hljs-keyword">this</span>._stateSet, <span class="hljs-keyword">this</span>._fragmentShader, <span class="hljs-keyword">this</span>._uniforms );
        }
        <span class="hljs-keyword">this</span>._stateSet.setAttributeAndModes( <span class="hljs-keyword">this</span>._program );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;

    }
} );</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>filter that switch its render target and its input at each frame
allowing to get input for last frame render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Composer.Filter.PingPong = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> cameraRtt0, rtt0, cameraRtt1, rtt1, fragmentShader, uniforms </span>) </span>{
    Composer.Filter.Custom.apply( <span class="hljs-keyword">this</span>, [ fragmentShader, uniforms ] );

    <span class="hljs-keyword">this</span>._cameraRtt0 = cameraRtt0;
    <span class="hljs-keyword">this</span>._rtt0 = rtt0;

    <span class="hljs-keyword">this</span>._cameraRtt1 = cameraRtt1;
    <span class="hljs-keyword">this</span>._rtt1 = rtt1;

    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'PingPong'</span>;
};

Composer.Filter.PingPong.prototype = MACROUTILS.objectInherit( Composer.Filter.Custom.prototype, {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Constraints:</p>
<ul>
<li>Next Filter: texture unit 0 === rtt0 &amp;&amp; texture unit 1 === rtt1</li>
<li>Previous Filter: the output of the previous filter if any
   will be binded to texture unit 0 of both camera stateset</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    interConnectFilters: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> composer, i, array </span>) </span>{

        <span class="hljs-keyword">var</span> filterStateSet = <span class="hljs-keyword">this</span>.getStateSet();

        <span class="hljs-keyword">var</span> st0 = <span class="hljs-keyword">this</span>._cameraRtt0.getOrCreateStateSet();
        <span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">this</span>._cameraRtt1.getOrCreateStateSet();</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>copy filter program and uniforms on the 2 cameras</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        st0.setAttributeAndModes( <span class="hljs-keyword">this</span>._program );
        st1.setAttributeAndModes( <span class="hljs-keyword">this</span>._program );</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>PingPong filter is a peculiar Filter where user provides the Camera
instead of compose::build creating them, and allowing user to provide
them in the ctor
To make sure we don’t forget any uniform
we make sure to get uniform from the filter itself and the uniform
from the parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> k, l, keys, unif, uniforms = <span class="hljs-keyword">this</span>.getStateSet().getUniformList();
        <span class="hljs-keyword">if</span> ( uniforms ) {
            keys = <span class="hljs-built_in">window</span>.Object.keys( uniforms );
            <span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>, l = keys.length; k &lt; l; k++ ) {
                unif = uniforms[ keys[ k ] ].getUniform();
                st0.addUniform( unif );
                st1.addUniform( unif );
            }
        }

        uniforms = <span class="hljs-keyword">this</span>._uniforms;
        <span class="hljs-keyword">if</span> ( uniforms ) {
            keys = <span class="hljs-built_in">window</span>.Object.keys( uniforms );
            <span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>, l = keys.length; k &lt; l; k++ ) {
                unif = uniforms[ keys[ k ] ];
                st0.addUniform( unif );
                st1.addUniform( unif );
            }
        }


        <span class="hljs-keyword">var</span> uniformTU0 = Uniform.createInt1( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture0'</span> );
        <span class="hljs-keyword">var</span> uniformTU1 = Uniform.createInt1( <span class="hljs-number">1</span>, <span class="hljs-string">'Texture1'</span> );

        st0.addUniform( uniformTU0 );
        st0.addUniform( uniformTU1 );

        st1.addUniform( uniformTU0 );
        st1.addUniform( uniformTU1 );</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>copy input on both camera
Composer::Build set the last render into the current filter stateset texture unit 0
we copy that into each camera as Texture unit 0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> inputTexture = filterStateSet.getTextureAttribute( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture'</span> );
        st0.setTextureAttributeAndModes( <span class="hljs-number">0</span>, inputTexture );
        st1.setTextureAttributeAndModes( <span class="hljs-number">0</span>, inputTexture );

        st0.setTextureAttributeAndModes( <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>._rtt1 );
        st1.setTextureAttributeAndModes( <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>._rtt0 );</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>if not the last filter
bind both result to next filter
rtt0 to texture unit 0
rtt0 to texture unit 1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( i !== array.length - <span class="hljs-number">1</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>just translate stateset to the next filter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> nextSt = array[ i + <span class="hljs-number">1</span> ].filter.getStateSet();

            nextSt.setTextureAttributeAndModes( <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>._rtt0 );
            nextSt.setTextureAttributeAndModes( <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>._rtt1 );

            nextSt.addUniform( uniformTU0 );
            nextSt.addUniform( uniformTU1 );

        }

        <span class="hljs-keyword">var</span> quad = Shape.createTexturedFullScreenFakeQuadGeometry();

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.buildGeometry )
            quad = <span class="hljs-keyword">this</span>.buildGeometry( quad );

        quad.setName( <span class="hljs-string">'composer layer'</span> );

        <span class="hljs-keyword">this</span>._cameraRtt0.addChild( quad );
        <span class="hljs-keyword">this</span>._cameraRtt1.addChild( quad );

        composer.addChild( <span class="hljs-keyword">this</span>._cameraRtt0 );
        composer.addChild( <span class="hljs-keyword">this</span>._cameraRtt1 );

        composer._textureRTT.push( <span class="hljs-keyword">this</span>._rtt0 );
        composer._textureRTT.push( <span class="hljs-keyword">this</span>._rtt1 );

        composer._cameraRTT.push( <span class="hljs-keyword">this</span>._cameraRtt0 );
        composer._cameraRTT.push( <span class="hljs-keyword">this</span>._cameraRtt1 );</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>hide one of the two pass, as we will render only one each frame</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._cameraRtt1.setNodeMask( <span class="hljs-number">0x0</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>last texture result, only one possible so the first will do</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._rtt0;

    },</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>PingPong</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">switch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">var</span> nodeMask0 = <span class="hljs-keyword">this</span>._cameraRtt0.getNodeMask();
        <span class="hljs-keyword">var</span> nodeMask1 = <span class="hljs-keyword">this</span>._cameraRtt1.getNodeMask();

        <span class="hljs-keyword">this</span>._cameraRtt0.setNodeMask( nodeMask1 );
        <span class="hljs-keyword">this</span>._cameraRtt1.setNodeMask( nodeMask0 );

    }

} );

Composer.Filter.AverageHBlur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> nbSamplesOpt, linear, unpack, pack </span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );
    <span class="hljs-keyword">this</span>._linear = linear !== <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.setBlurSize( nbSamplesOpt !== <span class="hljs-literal">undefined</span> ? nbSamplesOpt : <span class="hljs-number">5</span> );
    <span class="hljs-keyword">this</span>._unpack = unpack;
    <span class="hljs-keyword">this</span>._pack = pack;
    <span class="hljs-keyword">this</span>._pixelSize = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'AverageHBlur'</span> + <span class="hljs-keyword">this</span>._nbSamples;
};

Composer.Filter.AverageHBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
    setBlurSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> nbSamples </span>) </span>{
        <span class="hljs-keyword">if</span> ( nbSamples % <span class="hljs-number">2</span> !== <span class="hljs-number">1</span> ) {
            nbSamples += <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">this</span>._nbSamples = nbSamples;
        <span class="hljs-keyword">this</span>.dirty();
    },
    setPixelSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">this</span>._pixelSize = value;
        <span class="hljs-keyword">this</span>.dirty();
    },

    getUVOffset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'vec2(float('</span> + value + <span class="hljs-string">')/RenderSize[0], 0.0);'</span>;
    },
    getShaderBlurKernel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> nbSamples = <span class="hljs-keyword">this</span>._nbSamples;


        <span class="hljs-keyword">var</span> kernel = [];

        kernel.push( <span class="hljs-string">' pixel = unpack(Texture0, FragTexCoord0 );'</span> );
        kernel.push( <span class="hljs-string">' if (pixel.w == 0.0) { gl_FragColor = pixel; return; }'</span> );
        kernel.push( <span class="hljs-string">' vec2 offset;'</span> );
        <span class="hljs-keyword">var</span> i;
        <span class="hljs-keyword">var</span> numTexBlurStep = <span class="hljs-built_in">Math</span>.floor( nbSamples / <span class="hljs-number">2</span> );
        <span class="hljs-keyword">if</span> ( numTexBlurStep % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span> ) {
            nbSamples += <span class="hljs-number">1</span>;
            numTexBlurStep = <span class="hljs-built_in">Math</span>.floor( nbSamples / <span class="hljs-number">2</span> );
        }
        <span class="hljs-keyword">var</span> numFinalSample = numTexBlurStep * <span class="hljs-number">2.0</span> + <span class="hljs-number">1.0</span>;
        <span class="hljs-keyword">var</span> weight = <span class="hljs-number">1.0</span> / numFinalSample;
        <span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>._linear ) {
            <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; numTexBlurStep; i++ ) {
                kernel.push( <span class="hljs-string">' offset = '</span> + <span class="hljs-keyword">this</span>.getUVOffset( ( i + <span class="hljs-number">1</span> ) * <span class="hljs-keyword">this</span>._pixelSize ) );
                kernel.push( <span class="hljs-string">' pixel += unpack(Texture0, FragTexCoord0 + offset);'</span> );
                kernel.push( <span class="hljs-string">' pixel += unpack(Texture0, FragTexCoord0 - offset);'</span> );
            }
            kernel.push( <span class="hljs-string">' pixel *= float('</span> + weight + <span class="hljs-string">');'</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>console.log( ‘N: Sum = ‘ + ( weight + numTexBlurStep <em> weight </em> 2 ) );
console.log( ‘N: nbSample = ‘ + nbSamples + ‘ texBlurStep= ‘ + numTexBlurStep + ‘ finalSample= ‘ + numFinalSample );
console.log( ‘N: w = ‘ + weight );</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>using bilinear HW to divide texfetch by 2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> offset, offsetIdx;
            <span class="hljs-keyword">var</span> idx = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> weightTwo = ( <span class="hljs-number">1.0</span> - weight ) / ( numTexBlurStep * <span class="hljs-number">2.0</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>first pixel not same weight as others</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            kernel.push( <span class="hljs-string">' pixel *= float('</span> + weight + <span class="hljs-string">');'</span> );
            kernel.push( <span class="hljs-string">' vec4 pixelLin = vec4(0.0);'</span> );

            <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; numTexBlurStep; i += <span class="hljs-number">2</span> ) {

                offsetIdx = idx + <span class="hljs-number">0.5</span>; <span class="hljs-comment">//  ((i*weight + (i+1)*weight)/(weight+weight)) ===  (2i + 1) / 2 = i + 0.5</span>
                idx += <span class="hljs-number">2</span>;
                offset = <span class="hljs-keyword">this</span>.getUVOffset( offsetIdx * <span class="hljs-keyword">this</span>._pixelSize );

                kernel.push( <span class="hljs-string">' offset = '</span> + offset );

                kernel.push( <span class="hljs-string">' pixelLin += unpack(Texture0, FragTexCoord0 + offset);'</span> );
                kernel.push( <span class="hljs-string">' pixelLin += unpack(Texture0, FragTexCoord0 - offset);'</span> );
            }
            kernel.push( <span class="hljs-string">' pixel += pixelLin * float('</span> + weightTwo * <span class="hljs-number">2</span> + <span class="hljs-string">');'</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>console.log( ‘L: Sum = ‘ + ( weight + numTexBlurStep <em> weightTwo </em> 2 ) );
console.log( ‘L: nbSample = ‘ + nbSamples + ‘ texBlurStep= ‘ + numTexBlurStep + ‘ finalSample= ‘ + numFinalSample );
console.log( ‘N: w = ‘ + weight + ‘ numTexBlurStep  ‘ + numTexBlurStep + ‘ * w2 = ‘ + weightTwo );</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        }
        <span class="hljs-keyword">return</span> kernel;
    },
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-keyword">var</span> tex = <span class="hljs-keyword">this</span>._stateSet.getTextureAttribute( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture'</span> );
        <span class="hljs-keyword">if</span> ( tex &amp;&amp; <span class="hljs-keyword">this</span>._linear ) {
            tex.setMinFilter( <span class="hljs-string">'LINEAR'</span> );
            tex.setMagFilter( <span class="hljs-string">'LINEAR'</span> );
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>._linear = <span class="hljs-literal">false</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>var nbSamples = this._nbSamples;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> vtx = Composer.Filter.defaultVertexShader;
        <span class="hljs-keyword">var</span> fgt = [
            Composer.Filter.defaultFragmentShaderHeader,
            <span class="hljs-string">'uniform float width;'</span>,

            <span class="hljs-keyword">this</span>._unpack || <span class="hljs-string">'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }'</span>,
            <span class="hljs-keyword">this</span>._pack || <span class="hljs-string">'vec4 pack(vec4 pix) { return pix; }'</span>,

            <span class="hljs-string">'void main (void)'</span>,
            <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'  vec4 pixel;'</span>,
            <span class="hljs-keyword">this</span>.getShaderBlurKernel().join( <span class="hljs-string">'\n'</span> ),
            <span class="hljs-string">'  gl_FragColor = pack(pixel);'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, vtx + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, fgt + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._stateSet.getUniform( <span class="hljs-string">'Texture0'</span> ) === <span class="hljs-literal">undefined</span> ) {
            <span class="hljs-keyword">this</span>._stateSet.addUniform( Uniform.createInt1( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture0'</span> ) );
        }


        <span class="hljs-keyword">this</span>._stateSet.setAttributeAndModes( program );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );


Composer.Filter.AverageVBlur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> nbSamplesOpt, linear, unpack, pack </span>) </span>{
    Composer.Filter.AverageHBlur.call( <span class="hljs-keyword">this</span>, nbSamplesOpt, linear, unpack, pack );
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'AverageVBlur'</span> + <span class="hljs-keyword">this</span>._nbSamples;
};
Composer.Filter.AverageVBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.AverageHBlur.prototype, {
    getUVOffset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'vec2(0.0, float('</span> + value + <span class="hljs-string">')/RenderSize[1]);'</span>;
    }
} );

Composer.Filter.BilateralHBlur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> options, unpack, pack </span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );

    <span class="hljs-keyword">if</span> ( options === <span class="hljs-literal">undefined</span> ) {
        options = {};
    }

    <span class="hljs-keyword">var</span> nbSamplesOpt = options.nbSamples;
    <span class="hljs-keyword">var</span> depthTexture = options.depthTexture;
    <span class="hljs-keyword">var</span> radius = options.radius;

    <span class="hljs-keyword">this</span>.setBlurSize( nbSamplesOpt !== <span class="hljs-literal">undefined</span> ? nbSamplesOpt : <span class="hljs-number">5</span> );
    <span class="hljs-keyword">this</span>._depthTexture = depthTexture;
    <span class="hljs-keyword">this</span>._radius = Uniform.createFloat( <span class="hljs-number">1.0</span>, <span class="hljs-string">'radius'</span> );
    <span class="hljs-keyword">this</span>._pixelSize = Uniform.createFloat( <span class="hljs-number">1.0</span>, <span class="hljs-string">'pixelSize'</span> );
    <span class="hljs-keyword">this</span>.setRadius( radius );

    <span class="hljs-keyword">this</span>._unpack = unpack;
    <span class="hljs-keyword">this</span>._pack = pack;
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'BilateralHBlur'</span> + <span class="hljs-keyword">this</span>._nbSamples;
};

Composer.Filter.BilateralHBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
    setBlurSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> nbSamples </span>) </span>{
        <span class="hljs-keyword">if</span> ( nbSamples % <span class="hljs-number">2</span> !== <span class="hljs-number">1</span> ) {
            nbSamples += <span class="hljs-number">1</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Notify.log(‘BlurSize ‘ + nbSamples);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._nbSamples = nbSamples;
        <span class="hljs-keyword">this</span>.dirty();
    },
    setPixelSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">this</span>._pixelSize.setFloat( value );
    },
    setRadius: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> radius </span>) </span>{
        <span class="hljs-keyword">this</span>._radius.setFloat( radius ); <span class="hljs-comment">// *2.0;</span>
    },
    getUVOffset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'vec2(0.0, float('</span> + value + <span class="hljs-string">') * pixelSize )/RenderSize[1];'</span>;
    },
    getShaderBlurKernel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> nbSamples = <span class="hljs-keyword">this</span>._nbSamples;
        <span class="hljs-keyword">var</span> kernel = [];
        kernel.push( <span class="hljs-string">' pixel = unpack(Texture0, FragTexCoord0 );'</span> );
        kernel.push( <span class="hljs-string">' if (pixel.w &lt;= 0.0001) { gl_FragColor = vec4(1.0); return; }'</span> );
        kernel.push( <span class="hljs-string">' vec2 offset, tmpUV;'</span> );
        kernel.push( <span class="hljs-string">' depth = getDepthValue(unpack(Texture1, FragTexCoord0 ));'</span> );
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">Math</span>.ceil( nbSamples / <span class="hljs-number">2</span> ); i++ ) {
            kernel.push( <span class="hljs-string">' offset = '</span> + <span class="hljs-keyword">this</span>.getUVOffset( i ) );

            kernel.push( <span class="hljs-string">' tmpUV =  FragTexCoord0 + offset;'</span> );
            kernel.push( <span class="hljs-string">' tmpDepth = getDepthValue(unpack(Texture1, tmpUV ));'</span> );
            kernel.push( <span class="hljs-string">' if ( abs(depth-tmpDepth) &lt; radius) {'</span> );
            kernel.push( <span class="hljs-string">'   pixel += unpack(Texture0, tmpUV);'</span> );
            kernel.push( <span class="hljs-string">'   nbHits += 1.0;'</span> );
            kernel.push( <span class="hljs-string">' }'</span> );

            kernel.push( <span class="hljs-string">' tmpUV =  FragTexCoord0 - offset;'</span> );
            kernel.push( <span class="hljs-string">' tmpDepth = getDepthValue(unpack(Texture1, tmpUV ));'</span> );
            kernel.push( <span class="hljs-string">' if ( abs(depth-tmpDepth) &lt; radius) {'</span> );
            kernel.push( <span class="hljs-string">'   pixel += unpack(Texture0, tmpUV);'</span> );
            kernel.push( <span class="hljs-string">'   nbHits += 1.0;'</span> );
            kernel.push( <span class="hljs-string">' }'</span> );
        }
        kernel.push( <span class="hljs-string">' pixel /= nbHits;'</span> );
        <span class="hljs-keyword">return</span> kernel;
    },
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>var nbSamples = this._nbSamples;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> vtx = Composer.Filter.defaultVertexShader;
        <span class="hljs-keyword">var</span> fgt = [
            Composer.Filter.defaultFragmentShaderHeader,
            <span class="hljs-string">'uniform sampler2D Texture1;'</span>,
            <span class="hljs-string">'uniform float width;'</span>,
            <span class="hljs-string">'uniform mat4 projection;'</span>,
            <span class="hljs-string">'uniform float radius;'</span>,
            <span class="hljs-string">'uniform float pixelSize;'</span>,

            <span class="hljs-keyword">this</span>._unpack || <span class="hljs-string">'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }'</span>,
            <span class="hljs-keyword">this</span>._pack || <span class="hljs-string">'vec4 pack(vec4 pix) { return pix; }'</span>,

            <span class="hljs-string">'float znear,zfar,zrange;'</span>,
            <span class="hljs-string">''</span>,
            Composer.Filter.shaderUtils,
            <span class="hljs-string">''</span>,
            <span class="hljs-string">'float getDepthValue(vec4 v) {'</span>,
            <span class="hljs-string">'  float depth = unpack4x8ToFloat(v);'</span>,
            <span class="hljs-string">'  depth = depth*zrange+znear;'</span>,
            <span class="hljs-string">'  return -depth;'</span>,
            <span class="hljs-string">'}'</span>,

            <span class="hljs-string">'void main (void)'</span>,
            <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'  vec4 pixel;'</span>,
            <span class="hljs-string">'  float depth, tmpDepth;'</span>,
            <span class="hljs-string">'  znear = projection[3][2] / (projection[2][2]-1.0);'</span>,
            <span class="hljs-string">'  zfar = projection[3][2] / (projection[2][2]+1.0);'</span>,
            <span class="hljs-string">'  zrange = zfar-znear;'</span>,
            <span class="hljs-string">'  float nbHits = 1.0;'</span>,

            <span class="hljs-keyword">this</span>.getShaderBlurKernel().join( <span class="hljs-string">'\n'</span> ),
            <span class="hljs-string">'  gl_FragColor = pack(pixel);'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, vtx + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, fgt + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._stateSet.getUniform( <span class="hljs-string">'Texture0'</span> ) === <span class="hljs-literal">undefined</span> ) {
            <span class="hljs-keyword">this</span>._stateSet.addUniform( Uniform.createInt1( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture0'</span> ) );
        }
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._stateSet.getUniform( <span class="hljs-string">'Texture1'</span> ) === <span class="hljs-literal">undefined</span> ) {
            <span class="hljs-keyword">this</span>._stateSet.addUniform( Uniform.createInt1( <span class="hljs-number">1</span>, <span class="hljs-string">'Texture1'</span> ) );
        }
        <span class="hljs-keyword">this</span>._stateSet.addUniform( <span class="hljs-keyword">this</span>._radius );
        <span class="hljs-keyword">this</span>._stateSet.addUniform( <span class="hljs-keyword">this</span>._pixelSize );
        <span class="hljs-keyword">this</span>._stateSet.setTextureAttributeAndModes( <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>._depthTexture );
        <span class="hljs-keyword">this</span>._stateSet.setAttributeAndModes( program );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );

Composer.Filter.BilateralVBlur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> options, unpack, pack </span>) </span>{
    Composer.Filter.BilateralHBlur.call( <span class="hljs-keyword">this</span>, options, unpack, pack );
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'BilateralVBlur'</span> + <span class="hljs-keyword">this</span>._nbSamples;
};

Composer.Filter.BilateralVBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.BilateralHBlur.prototype, {
    getUVOffset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'vec2(float('</span> + value + <span class="hljs-string">')*pixelSize/RenderSize[0],0.0);'</span>;
    }
} );</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>InputTexture is a fake filter to setup the first texture
in the composer pipeline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Composer.Filter.InputTexture = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> texture </span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );
    <span class="hljs-keyword">this</span>._stateSet.setTextureAttributeAndModes( <span class="hljs-number">0</span>, texture );
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'InputTexture'</span>;
};
Composer.Filter.InputTexture.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Operate a Gaussian horizontal blur</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Composer.Filter.HBlur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> nbSamplesOpt, linear, unpack, pack </span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );
    <span class="hljs-keyword">this</span>._linear = linear !== <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.setBlurSize( nbSamplesOpt !== <span class="hljs-literal">undefined</span> ? nbSamplesOpt : <span class="hljs-number">5</span> );
    <span class="hljs-keyword">this</span>._unpack = unpack;
    <span class="hljs-keyword">this</span>._pack = pack;
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'HBlur'</span> + <span class="hljs-keyword">this</span>._nbSamples;
};

Composer.Filter.HBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
    setBlurSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> nbSamples </span>) </span>{
        <span class="hljs-keyword">if</span> ( nbSamples % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span> ) {
            nbSamples += <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">this</span>._nbSamples = nbSamples;
        <span class="hljs-keyword">this</span>.dirty();
    },
    getUVOffset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>TODO: could compute that in JS and remove 1 div per kernel step</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-string">'vec2(float('</span> + value + <span class="hljs-string">')/ RenderSize[0], 0.0) ;'</span>;
    },
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> nbSamples = <span class="hljs-keyword">this</span>._nbSamples;</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>TODO: get rendersize from that and precompute
offset when possible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> tex = <span class="hljs-keyword">this</span>._stateSet.getTextureAttribute( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture'</span> );
        <span class="hljs-keyword">if</span> ( tex &amp;&amp; <span class="hljs-keyword">this</span>._linear ) {
            tex.setMinFilter( <span class="hljs-string">'LINEAR'</span> );
            tex.setMagFilter( <span class="hljs-string">'LINEAR'</span> );
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>._linear = <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">var</span> vtx = Composer.Filter.defaultVertexShader;</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p><a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a>
outermost are near 0, so unless float buffer…
at samples = 6 already it’s 1/32 = 0.03
so we lessen texFetch (allow higher kernel size with less texfetch)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> weightMin = <span class="hljs-number">0.005</span> / nbSamples;
        <span class="hljs-keyword">var</span> coeffIdx = nbSamples;
        <span class="hljs-keyword">var</span> weights = Composer.Filter.Helper.getOrCreatePascalCoefficients( coeffIdx );
        <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Math</span>.floor( coeffIdx / <span class="hljs-number">2.0</span> );

        <span class="hljs-keyword">var</span> kernel = [];
        kernel.push( <span class="hljs-string">' pixel = float('</span> + weights[ start ] + <span class="hljs-string">')*unpack(Texture0, FragTexCoord0 ).rgb;'</span> );

        kernel.push( <span class="hljs-string">' vec2 offset;'</span> );
        <span class="hljs-keyword">var</span> idx, i, weight, offset, offsetIdx;
        <span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>._linear ) {
            idx = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> ( i = start + <span class="hljs-number">1</span>; i &lt; nbSamples; i++ ) {
                weight = weights[ i ];

                <span class="hljs-keyword">if</span> ( weight &lt; weightMin ) <span class="hljs-keyword">break</span>;

                offsetIdx = idx++;
                offset = <span class="hljs-keyword">this</span>.getUVOffset( offsetIdx );

                kernel.push( <span class="hljs-string">' offset = '</span> + offset );
                kernel.push( <span class="hljs-string">' pixel += '</span> + weight + <span class="hljs-string">'* unpack(Texture0, (FragTexCoord0.xy + offset.xy)).rgb;'</span> );
                kernel.push( <span class="hljs-string">' pixel += '</span> + weight + <span class="hljs-string">'* unpack(Texture0, (FragTexCoord0.xy - offset.xy)).rgb;'</span> );
            }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>using bilinear HW to divide texfetch by 2
<a href="http://www.rastergrid.com/blog/wp-content/uploads/2010/09/equation.png">http://www.rastergrid.com/blog/wp-content/uploads/2010/09/equation.png</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            idx = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> ( i = start + <span class="hljs-number">1</span>; i &lt; nbSamples; i += <span class="hljs-number">2</span> ) {
                <span class="hljs-keyword">var</span> weightT1 = weights[ i ];
                <span class="hljs-keyword">var</span> weightT2 = weights[ i + <span class="hljs-number">1</span> ];

                weight = weightT1 + weightT2;

                <span class="hljs-keyword">if</span> ( weight &lt; weightMin ) <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">var</span> offsetT1 = idx;
                <span class="hljs-keyword">var</span> offsetT2 = idx + <span class="hljs-number">1</span>;
                idx += <span class="hljs-number">2</span>;

                offsetIdx = ( offsetT1 * weightT1 + offsetT2 * weightT2 ) / weight;
                offset = <span class="hljs-keyword">this</span>.getUVOffset( offsetIdx );

                kernel.push( <span class="hljs-string">' offset = '</span> + offset );
                kernel.push( <span class="hljs-string">' pixel += '</span> + weight + <span class="hljs-string">'* unpack(Texture0, (FragTexCoord0.xy + offset.xy)).rgb;'</span> );
                kernel.push( <span class="hljs-string">' pixel += '</span> + weight + <span class="hljs-string">'* unpack(Texture0, (FragTexCoord0.xy - offset.xy)).rgb;'</span> );
            }
        }
        <span class="hljs-keyword">var</span> fgt = [
            Composer.Filter.defaultFragmentShaderHeader,
            <span class="hljs-string">'uniform float width;'</span>,

            <span class="hljs-keyword">this</span>._unpack || <span class="hljs-string">'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }'</span>,
            <span class="hljs-keyword">this</span>._pack || <span class="hljs-string">'vec4 pack(vec4 pix) { return pix; }'</span>,

            <span class="hljs-string">'void main (void)'</span>,
            <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'  vec3 pixel;'</span>,
            kernel.join( <span class="hljs-string">'\n'</span> ),
            <span class="hljs-string">'  gl_FragColor = pack(vec4(pixel, 1.0));'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, vtx + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, fgt + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._stateSet.getUniform( <span class="hljs-string">'Texture0'</span> ) === <span class="hljs-literal">undefined</span> ) {
            <span class="hljs-keyword">this</span>._stateSet.addUniform( Uniform.createInt1( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture0'</span> ) );
        }
        <span class="hljs-keyword">this</span>._stateSet.setAttributeAndModes( program );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Operate a Gaussian vertical blur</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Composer.Filter.VBlur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> nbSamplesOpt, linear, unpack, pack </span>) </span>{
    Composer.Filter.HBlur.call( <span class="hljs-keyword">this</span>, nbSamplesOpt, linear, unpack, pack );
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'VBlur'</span> + <span class="hljs-keyword">this</span>._nbSamples;
};

Composer.Filter.VBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.HBlur.prototype, {
    getUVOffset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'vec2(0.0, float('</span> + value + <span class="hljs-string">')/RenderSize[1]) ;'</span>;
    }
} );</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Sobel filter
<a href="http://en.wikipedia.org/wiki/Sobel_operator">http://en.wikipedia.org/wiki/Sobel_operator</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Composer.Filter.SobelFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );
    <span class="hljs-keyword">this</span>._color = Uniform.createFloat3( Vec3.createAndSet( <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ), <span class="hljs-string">'color'</span> );
    <span class="hljs-keyword">this</span>._factor = Uniform.createFloat( <span class="hljs-number">1.0</span>, <span class="hljs-string">'factor'</span> );
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'SobelFilter'</span>;
};

Composer.Filter.SobelFilter.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
    setColor: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> color </span>) </span>{
        <span class="hljs-keyword">this</span>._color.setVec3( color );
    },
    setFactor: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> f </span>) </span>{
        <span class="hljs-keyword">this</span>._factor.setFloat( f );
    },
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> stateSet = <span class="hljs-keyword">this</span>._stateSet;
        <span class="hljs-keyword">var</span> vtx = Composer.Filter.defaultVertexShader;
        <span class="hljs-keyword">var</span> fgt = [
            <span class="hljs-string">''</span>,
            Composer.Filter.defaultFragmentShaderHeader,
            <span class="hljs-string">'uniform vec3 color;'</span>,
            <span class="hljs-string">'uniform float factor;'</span>,
            <span class="hljs-string">'void main (void)'</span>,
            <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'  float fac0 = 2.0;'</span>,
            <span class="hljs-string">'  float fac1 = 1.0;'</span>,
            <span class="hljs-string">'  float offsetx = 1.0/RenderSize[0];'</span>,
            <span class="hljs-string">'  float offsety = 1.0/RenderSize[1];'</span>,
            <span class="hljs-string">'  vec4 texel0 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, offsety));'</span>,
            <span class="hljs-string">'  vec4 texel1 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, 0.0));'</span>,
            <span class="hljs-string">'  vec4 texel2 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, -offsety));'</span>,
            <span class="hljs-string">'  vec4 texel3 = texture2D(Texture0, FragTexCoord0 + vec2(0.0, -offsety));'</span>,
            <span class="hljs-string">'  vec4 texel4 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, -offsety));'</span>,
            <span class="hljs-string">'  vec4 texel5 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, 0.0));'</span>,
            <span class="hljs-string">'  vec4 texel6 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, offsety));'</span>,
            <span class="hljs-string">'  vec4 texel7 = texture2D(Texture0, FragTexCoord0 + vec2(0.0, offsety));'</span>,
            <span class="hljs-string">'  vec4 rowx = -fac0*texel5 + fac0*texel1 +  -fac1*texel6 + fac1*texel0 + -fac1*texel4 + fac1*texel2;'</span>,
            <span class="hljs-string">'  vec4 rowy = -fac0*texel3 + fac0*texel7 +  -fac1*texel4 + fac1*texel6 + -fac1*texel2 + fac1*texel0;'</span>,
            <span class="hljs-string">'  float mag = sqrt(dot(rowy,rowy)+dot(rowx,rowx));'</span>,
            <span class="hljs-string">'  if (mag &lt; 1.0/255.0) discard;'</span>,
            <span class="hljs-string">'  mag *= factor;'</span>,
            <span class="hljs-string">'  mag = min(1.0, mag);'</span>,
            <span class="hljs-string">'  gl_FragColor = vec4(color*mag,mag);'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, vtx + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, fgt + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        stateSet.setAttributeAndModes( program );
        stateSet.addUniform( <span class="hljs-keyword">this</span>._color );
        stateSet.addUniform( <span class="hljs-keyword">this</span>._factor );
        stateSet.addUniform( Uniform.createInt1( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture0'</span> ) );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );

Composer.Filter.BlendMix = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );
    <span class="hljs-keyword">var</span> texture0, texture1, mixValue;
    <span class="hljs-keyword">var</span> unit0 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> unit1 = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> stateSet = <span class="hljs-keyword">this</span>._stateSet;
    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">3</span> ) {
        texture0 = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">0</span> ];
        texture1 = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">1</span> ];
        mixValue = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">2</span> ];
        unit0 = <span class="hljs-number">1</span>;
        unit1 = <span class="hljs-number">2</span>;
        stateSet.setTextureAttributeAndModes( unit0, texture0 );
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span> ) {
        texture1 = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">0</span> ];
        mixValue = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">1</span> ];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span> ) {
        texture1 = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">0</span> ];
        mixValue = <span class="hljs-number">0.5</span>;
    }
    stateSet.setTextureAttributeAndModes( unit1, texture1 );
    stateSet.addUniform( Uniform.createInt1( unit0, <span class="hljs-string">'Texture0'</span> ) );
    stateSet.addUniform( Uniform.createInt1( unit1, <span class="hljs-string">'Texture1'</span> ) );
    <span class="hljs-keyword">this</span>._mixValueUniform = Uniform.createFloat1( mixValue, <span class="hljs-string">'MixValue'</span> );
    stateSet.addUniform( <span class="hljs-keyword">this</span>._mixValueUniform );
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'BlendMix'</span>;
};

Composer.Filter.BlendMix.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
    getBlendFactorUniform: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._mixValueUniform;
    },

    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> stateSet = <span class="hljs-keyword">this</span>._stateSet;
        <span class="hljs-keyword">var</span> vtx = Composer.Filter.defaultVertexShader;
        <span class="hljs-keyword">var</span> fgt = [
            <span class="hljs-string">''</span>,
            Composer.Filter.defaultFragmentShaderHeader,
            <span class="hljs-string">'uniform sampler2D Texture1;'</span>,
            <span class="hljs-string">'uniform float MixValue;'</span>,

            <span class="hljs-string">'void main (void)'</span>,
            <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'  gl_FragColor = mix(texture2D(Texture0,FragTexCoord0), texture2D(Texture1,FragTexCoord0),MixValue);'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, vtx + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, fgt + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        stateSet.setAttributeAndModes( program );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );


Composer.Filter.BlendMultiply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );
    <span class="hljs-keyword">var</span> stateSet = <span class="hljs-keyword">this</span>._stateSet;
    <span class="hljs-keyword">var</span> texture0, texture1;
    <span class="hljs-keyword">var</span> unit0 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> unit1 = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span> ) {
        texture0 = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">0</span> ];
        texture1 = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">1</span> ];
        unit0 = <span class="hljs-number">1</span>;
        unit0 = <span class="hljs-number">2</span>;
        stateSet.setTextureAttributeAndModes( unit0, texture0 );
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span> ) {
        texture1 = <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">0</span> ];
    }
    stateSet.setTextureAttributeAndModes( unit1, texture1 );
    stateSet.addUniform( Uniform.createInt1( unit0, <span class="hljs-string">'Texture0'</span> ) );
    stateSet.addUniform( Uniform.createInt1( unit1, <span class="hljs-string">'Texture1'</span> ) );
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'BlendMultiply'</span>;
};

Composer.Filter.BlendMultiply.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> vtx = Composer.Filter.defaultVertexShader;
        <span class="hljs-keyword">var</span> fgt = [
            <span class="hljs-string">''</span>,
            Composer.Filter.defaultFragmentShaderHeader,
            <span class="hljs-string">'uniform sampler2D Texture1;'</span>,
            <span class="hljs-string">'uniform float MixValue;'</span>,

            <span class="hljs-string">'void main (void)'</span>,
            <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'  gl_FragColor = texture2D(Texture0,FragTexCoord0)*texture2D(Texture1,FragTexCoord0);'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, vtx + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, fgt + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        <span class="hljs-keyword">this</span>._stateSet.setAttributeAndModes( program );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );

Composer.Filter.SSAO = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> options </span>) </span>{
    Composer.Filter.call( <span class="hljs-keyword">this</span> );

    <span class="hljs-keyword">var</span> stateSet = <span class="hljs-keyword">this</span>._stateSet;
    <span class="hljs-keyword">var</span> nbSamples = <span class="hljs-number">16</span>;
    <span class="hljs-keyword">var</span> radius = <span class="hljs-number">0.05</span>;
    <span class="hljs-keyword">if</span> ( options !== <span class="hljs-literal">undefined</span> ) {
        <span class="hljs-keyword">if</span> ( options.nbSamples !== <span class="hljs-literal">undefined</span> )
            nbSamples = options.nbSamples;

        <span class="hljs-keyword">if</span> ( options.radius !== <span class="hljs-literal">undefined</span> )
            radius = options.radius;
    }

    <span class="hljs-keyword">var</span> textureNormal = options.normal;
    <span class="hljs-keyword">var</span> texturePosition = options.position;
    <span class="hljs-keyword">this</span>._radius = radius;
    <span class="hljs-keyword">this</span>._nbSamples = nbSamples;
    <span class="hljs-keyword">this</span>._noiseTextureSize = <span class="hljs-number">16</span>;
    <span class="hljs-keyword">this</span>._sceneRadius = <span class="hljs-number">2.0</span>;

    stateSet.addUniform( Uniform.createFloat1( <span class="hljs-number">1.0</span>, <span class="hljs-string">'Power'</span> ) );
    stateSet.addUniform( Uniform.createFloat1( radius, <span class="hljs-string">'Radius'</span> ) );
    stateSet.addUniform( Uniform.createInt1( <span class="hljs-number">0</span>, <span class="hljs-string">'Texture0'</span> ) );
    stateSet.addUniform( Uniform.createInt1( <span class="hljs-number">1</span>, <span class="hljs-string">'Texture1'</span> ) );
    stateSet.addUniform( Uniform.createInt1( <span class="hljs-number">2</span>, <span class="hljs-string">'Texture2'</span> ) );
    stateSet.addUniform( Uniform.createFloat1( <span class="hljs-number">0.1</span>, <span class="hljs-string">'AngleLimit'</span> ) );

    <span class="hljs-keyword">var</span> w = textureNormal.getWidth();
    <span class="hljs-keyword">var</span> h = textureNormal.getHeight();
    <span class="hljs-keyword">this</span>._size = Vec2.createAndSet( w, h );

    stateSet.setTextureAttributeAndModes( <span class="hljs-number">0</span>, textureNormal );
    stateSet.setTextureAttributeAndModes( <span class="hljs-number">1</span>, texturePosition );

    <span class="hljs-keyword">this</span>.initNoise();
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'SSAO'</span>;
};

Composer.Filter.SSAO.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {

    initNoise: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> sizeNoise = <span class="hljs-keyword">this</span>._noiseTextureSize;
        <span class="hljs-keyword">var</span> noise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( sizeNoise * sizeNoise * <span class="hljs-number">3</span> );
        ( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> array </span>) </span>{
            <span class="hljs-keyword">var</span> n = Vec2.createAndSet( <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span> );
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; sizeNoise * sizeNoise; i++ ) {
                n[ <span class="hljs-number">0</span> ] = <span class="hljs-number">2.0</span> * ( <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span> );
                n[ <span class="hljs-number">1</span> ] = <span class="hljs-number">2.0</span> * ( <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span> );

                Vec2.normalize( n, n );
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">0</span> ] = <span class="hljs-number">255</span> * ( n[ <span class="hljs-number">0</span> ] * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span> );
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span> ] = <span class="hljs-number">255</span> * ( n[ <span class="hljs-number">1</span> ] * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span> );
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span> ] = <span class="hljs-number">255</span> * <span class="hljs-number">0.5</span>;
            }
        } )( noise );

        <span class="hljs-keyword">var</span> noiseTexture = <span class="hljs-keyword">new</span> Texture();
        noiseTexture.setWrapS( <span class="hljs-string">'REPEAT'</span> );
        noiseTexture.setWrapT( <span class="hljs-string">'REPEAT'</span> );
        noiseTexture.setMinFilter( <span class="hljs-string">'NEAREST'</span> );
        noiseTexture.setMagFilter( <span class="hljs-string">'NEAREST'</span> );

        noiseTexture.setTextureSize( sizeNoise, sizeNoise );
        noiseTexture.setImage( <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>( noise ), <span class="hljs-string">'RGB'</span> );
        <span class="hljs-keyword">this</span>._noiseTexture = noiseTexture;
    },
    setSceneRadius: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">this</span>._sceneRadius = value;
        <span class="hljs-keyword">this</span>.dirty();
    },
    setAngleLimit: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">var</span> uniform = <span class="hljs-keyword">this</span>._stateSet.getUniform( <span class="hljs-string">'AngleLimit'</span> );
        uniform.setFloat( value );
    },
    setNbSamples: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">if</span> ( value === <span class="hljs-keyword">this</span>._nbSamples ) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">this</span>._nbSamples = <span class="hljs-built_in">Math</span>.floor( value );
        <span class="hljs-keyword">this</span>.dirty();
    },
    setRadius: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">var</span> uniform = <span class="hljs-keyword">this</span>._stateSet.getUniform( <span class="hljs-string">'Radius'</span> );
        uniform.setFloat( value );
    },
    setPower: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
        <span class="hljs-keyword">var</span> uniform = <span class="hljs-keyword">this</span>._stateSet.getUniform( <span class="hljs-string">'Power'</span> );
        uniform.setFloat( value );
    },
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> stateSet = <span class="hljs-keyword">this</span>._stateSet;
        <span class="hljs-keyword">var</span> nbSamples = <span class="hljs-keyword">this</span>._nbSamples;
        <span class="hljs-keyword">var</span> kernel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( nbSamples * <span class="hljs-number">4</span> );
        ( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> array </span>) </span>{
            <span class="hljs-keyword">var</span> v = Vec3.create();
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nbSamples; i++ ) {
                v[ <span class="hljs-number">0</span> ] = <span class="hljs-number">2.0</span> * ( <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span> );
                v[ <span class="hljs-number">1</span> ] = <span class="hljs-number">2.0</span> * ( <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span> );
                v[ <span class="hljs-number">2</span> ] = <span class="hljs-built_in">Math</span>.random();

                Vec3.normalize( v, v );
                <span class="hljs-keyword">var</span> scale = <span class="hljs-built_in">Math</span>.max( i / nbSamples, <span class="hljs-number">0.1</span> );
                scale = <span class="hljs-number">0.1</span> + ( <span class="hljs-number">1.0</span> - <span class="hljs-number">0.1</span> ) * ( scale * scale );
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">0</span> ] = v[ <span class="hljs-number">0</span> ];
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span> ] = v[ <span class="hljs-number">1</span> ];
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span> ] = v[ <span class="hljs-number">2</span> ];
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">3</span> ] = scale;
            }
        } )( kernel );


        stateSet.setTextureAttributeAndModes( <span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>._noiseTexture );
        <span class="hljs-keyword">var</span> uniform = stateSet.getUniform( <span class="hljs-string">'noiseSampling'</span> );
        <span class="hljs-keyword">if</span> ( uniform === <span class="hljs-literal">undefined</span> ) {
            uniform = Uniform.createFloat2( Vec2.createAndSet( <span class="hljs-keyword">this</span>._size[ <span class="hljs-number">0</span> ] / <span class="hljs-keyword">this</span>._noiseTextureSize, <span class="hljs-keyword">this</span>._size[ <span class="hljs-number">1</span> ] / <span class="hljs-keyword">this</span>._noiseTextureSize ), <span class="hljs-string">'noiseSampling'</span> );
            stateSet.addUniform( uniform );
        } <span class="hljs-keyword">else</span> {
            uniform.setVec2( Vec2.createAndSet( <span class="hljs-keyword">this</span>._size[ <span class="hljs-number">0</span> ] / <span class="hljs-keyword">this</span>._noiseTextureSize, <span class="hljs-keyword">this</span>._size[ <span class="hljs-number">1</span> ] / <span class="hljs-keyword">this</span>._noiseTextureSize ) );
        }
        <span class="hljs-keyword">var</span> vertexShader = [
            <span class="hljs-string">''</span>,
            <span class="hljs-string">'attribute vec3 Vertex;'</span>,
            <span class="hljs-string">'attribute vec2 TexCoord0;'</span>,
            <span class="hljs-string">'varying vec2 FragTexCoord0;'</span>,
            <span class="hljs-string">'uniform mat4 ModelViewMatrix;'</span>,
            <span class="hljs-string">'uniform mat4 ProjectionMatrix;'</span>,
            <span class="hljs-string">'void main(void) {'</span>,
            <span class="hljs-string">'  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);'</span>,
            <span class="hljs-string">'  FragTexCoord0 = TexCoord0;'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> kernelglsl = [];
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nbSamples; i++ ) {
            kernelglsl.push( <span class="hljs-string">'kernel['</span> + i + <span class="hljs-string">'] = vec4('</span> + kernel[ i * <span class="hljs-number">3</span> ] + <span class="hljs-string">','</span> + kernel[ i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span> ] + <span class="hljs-string">', '</span> + kernel[ i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span> ] + <span class="hljs-string">', '</span> + kernel[ i * <span class="hljs-number">3</span> + <span class="hljs-number">3</span> ] + <span class="hljs-string">');'</span> );
        }
        kernelglsl = kernelglsl.join( <span class="hljs-string">'\n'</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>var ssaoRadiusMin = this._sceneRadius <em> 0.002;
var ssaoRadiusMax = this._sceneRadius </em> 0.05;
var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">var</span> fragmentShader = [
            <span class="hljs-string">''</span>,
            Composer.Filter.defaultFragmentShaderHeader,
            <span class="hljs-string">'uniform sampler2D Texture1;'</span>,
            <span class="hljs-string">'uniform sampler2D Texture2;'</span>,
            <span class="hljs-string">'uniform mat4 projection;'</span>,
            <span class="hljs-string">'uniform vec2 noiseSampling;'</span>,
            <span class="hljs-string">'uniform float Power;'</span>, <span class="hljs-comment">//'+ '{ 'min': 0.1, 'max': 16.0, 'step': 0.1, 'value': 1.0 }',</span>
            <span class="hljs-string">'uniform float Radius;'</span>, <span class="hljs-comment">//'+ '{ 'min': ' + ssaoRadiusMin +', 'max': ' + ssaoRadiusMax + ', 'step': '+ ssaoRadiusStep + ', 'value': 0.01 }',</span>
            <span class="hljs-string">'uniform float AngleLimit;'</span>,
            <span class="hljs-string">'#define NB_SAMPLES '</span> + <span class="hljs-keyword">this</span>._nbSamples,
            <span class="hljs-string">'float depth;'</span>,
            <span class="hljs-string">'vec3 normal;'</span>,
            <span class="hljs-string">'vec4 position;'</span>,
            <span class="hljs-string">'vec4 kernel['</span> + nbSamples + <span class="hljs-string">'];'</span>,


            <span class="hljs-string">'mat3 computeBasis()'</span>,
            <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'  vec2 uvrand = FragTexCoord0*noiseSampling;'</span>,
            <span class="hljs-string">'  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);'</span>,
            <span class="hljs-string">'  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));'</span>,
            <span class="hljs-string">'  vec3 bitangent = cross(normal, tangent);'</span>,
            <span class="hljs-string">'  mat3 tbn = mat3(tangent, bitangent, normal);'</span>,
            <span class="hljs-string">'  return tbn;'</span>,
            <span class="hljs-string">'}'</span>,

            <span class="hljs-string">'void main (void)'</span>,
            <span class="hljs-string">'{'</span>,
            kernelglsl,
            <span class="hljs-string">'  position = texture2D(Texture1, FragTexCoord0);'</span>,
            <span class="hljs-string">'  vec4 p = texture2D(Texture0, FragTexCoord0);'</span>,
            <span class="hljs-string">'  depth = p.w;'</span>,
            <span class="hljs-string">'  normal = vec3(p);'</span>,
            <span class="hljs-string">'  if ( position.w == 0.0) {'</span>,
            <span class="hljs-string">'     gl_FragColor = vec4(1.0,1.0,1.0,0.0);'</span>,
            <span class="hljs-string">'     return;'</span>,
            <span class="hljs-string">'  }'</span>,
            <span class="hljs-string">''</span>,
            <span class="hljs-string">' mat3 tbn = computeBasis();'</span>,
            <span class="hljs-string">' float occlusion = 0.0;'</span>,
            <span class="hljs-string">' for (int i = 0; i &lt; NB_SAMPLES; i++) {'</span>,
            <span class="hljs-string">'    vec3 vecKernel = vec3(kernel[i]);'</span>,
            <span class="hljs-string">'    vecKernel[2] = max(AngleLimit,vecKernel[2]);'</span>,
            <span class="hljs-string">'    vec3 sample = tbn * vecKernel;'</span>,
            <span class="hljs-string">'    vec3 dir = sample;'</span>,
            <span class="hljs-string">'    float w = dot(dir, normal);'</span>,
            <span class="hljs-string">'    float dist = 1.0-kernel[i].w;'</span>,
            <span class="hljs-string">'    w *= dist*dist*Power;'</span>,
            <span class="hljs-string">'    sample = dir * float(Radius) + position.xyz;'</span>,

            <span class="hljs-string">'    vec4 offset = projection * vec4(sample,1.0);'</span>,
            <span class="hljs-string">'    offset.xy /= offset.w;'</span>,
            <span class="hljs-string">'    offset.xy = offset.xy * 0.5 + 0.5;'</span>,

            <span class="hljs-string">'    float sample_depth = texture2D(Texture1, offset.xy).z;'</span>,
            <span class="hljs-string">'    float range_check = abs(sample.z - sample_depth) &lt; float(Radius) ? 1.0 : 0.0;'</span>,
            <span class="hljs-string">'    occlusion += (sample_depth &gt; sample.z ? 1.0 : 0.0) * range_check*w;'</span>,

            <span class="hljs-string">' }'</span>,
            <span class="hljs-string">' occlusion = 1.0 - (occlusion / float(NB_SAMPLES));'</span>,
            <span class="hljs-string">' gl_FragColor = vec4(vec3(occlusion),1.0);'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, vertexShader + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, fragmentShader + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        stateSet.setAttributeAndModes( program );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );

Composer.Filter.SSAO8 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> options </span>) </span>{
    Composer.Filter.SSAO.call( <span class="hljs-keyword">this</span>, options );
    <span class="hljs-keyword">this</span>._fragmentName = <span class="hljs-string">'SSAO8'</span>;
};

Composer.Filter.SSAO8.prototype = MACROUTILS.objectInherit( Composer.Filter.SSAO.prototype, {
    buildGeometry: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> quad </span>) </span>{
        quad.getAttributes().TexCoord1 = <span class="hljs-keyword">this</span>._texCoord1;
        <span class="hljs-keyword">return</span> quad;
    },
    build: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> stateSet = <span class="hljs-keyword">this</span>._stateSet;
        <span class="hljs-keyword">var</span> nbSamples = <span class="hljs-keyword">this</span>._nbSamples;
        <span class="hljs-keyword">var</span> kernel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( nbSamples * <span class="hljs-number">4</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>var angleLimit = this._angleLimit;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> array </span>) </span>{
            <span class="hljs-keyword">var</span> v = Vec3.create();
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nbSamples; i++ ) {
                v[ <span class="hljs-number">0</span> ] = <span class="hljs-number">2.0</span> * ( <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span> );
                v[ <span class="hljs-number">1</span> ] = <span class="hljs-number">2.0</span> * ( <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span> );
                v[ <span class="hljs-number">2</span> ] = <span class="hljs-built_in">Math</span>.random();

                Vec3.normalize( v, v );
                <span class="hljs-keyword">var</span> scale = <span class="hljs-built_in">Math</span>.max( i / nbSamples, <span class="hljs-number">0.1</span> );
                scale = <span class="hljs-number">0.1</span> + ( <span class="hljs-number">1.0</span> - <span class="hljs-number">0.1</span> ) * ( scale * scale );
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">0</span> ] = v[ <span class="hljs-number">0</span> ];
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span> ] = v[ <span class="hljs-number">1</span> ];
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span> ] = v[ <span class="hljs-number">2</span> ];
                array[ i * <span class="hljs-number">3</span> + <span class="hljs-number">3</span> ] = scale;
            }
        } )( kernel );</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>var sizeNoise = this._noiseTextureSize;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        stateSet.setTextureAttributeAndModes( <span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>._noiseTexture );
        <span class="hljs-keyword">var</span> uniform = stateSet.getUniform( <span class="hljs-string">'noiseSampling'</span> );
        <span class="hljs-keyword">if</span> ( uniform === <span class="hljs-literal">undefined</span> ) {
            uniform = Uniform.createFloat2( Vec2.createAndSet( <span class="hljs-keyword">this</span>._size[ <span class="hljs-number">0</span> ] / <span class="hljs-keyword">this</span>._noiseTextureSize, <span class="hljs-keyword">this</span>._size[ <span class="hljs-number">1</span> ] / <span class="hljs-keyword">this</span>._noiseTextureSize ), <span class="hljs-string">'noiseSampling'</span> );
            stateSet.addUniform( uniform );
        } <span class="hljs-keyword">else</span> {
            uniform.setVec2( Vec2.createAndSet( <span class="hljs-keyword">this</span>._size[ <span class="hljs-number">0</span> ] / <span class="hljs-keyword">this</span>._noiseTextureSize, <span class="hljs-keyword">this</span>._size[ <span class="hljs-number">1</span> ] / <span class="hljs-keyword">this</span>._noiseTextureSize ) );
        }
        <span class="hljs-keyword">var</span> vertexShader = [
            <span class="hljs-string">''</span>,
            <span class="hljs-string">'attribute vec3 Vertex;'</span>,
            <span class="hljs-string">'attribute vec2 TexCoord0;'</span>,
            <span class="hljs-string">'attribute vec3 TexCoord1;'</span>,
            <span class="hljs-string">'varying vec2 FragTexCoord0;'</span>,
            <span class="hljs-string">'varying vec3 FragTexCoord1;'</span>,
            <span class="hljs-string">'uniform mat4 ModelViewMatrix;'</span>,
            <span class="hljs-string">'uniform mat4 ProjectionMatrix;'</span>,
            <span class="hljs-string">'void main(void) {'</span>,
            <span class="hljs-string">'  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);'</span>,
            <span class="hljs-string">'  FragTexCoord0 = TexCoord0;'</span>,
            <span class="hljs-string">'  FragTexCoord1 = TexCoord1;'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> kernelglsl = [];
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nbSamples; i++ ) {
            kernelglsl.push( <span class="hljs-string">'kernel['</span> + i + <span class="hljs-string">'] = vec4('</span> + kernel[ i * <span class="hljs-number">3</span> ] + <span class="hljs-string">','</span> + kernel[ i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span> ] + <span class="hljs-string">', '</span> + kernel[ i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span> ] + <span class="hljs-string">', '</span> + kernel[ i * <span class="hljs-number">3</span> + <span class="hljs-number">3</span> ] + <span class="hljs-string">');'</span> );
        }
        kernelglsl = kernelglsl.join( <span class="hljs-string">'\n'</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>var ssaoRadiusMin = this._sceneRadius <em> 0.002;
var ssaoRadiusMax = this._sceneRadius </em> 0.05;
var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">var</span> fragmentShader = [
            <span class="hljs-string">''</span>,
            Composer.Filter.defaultFragmentShaderHeader,
            <span class="hljs-string">'varying vec3 FragTexCoord1;'</span>,
            <span class="hljs-string">'uniform sampler2D Texture1;'</span>,
            <span class="hljs-string">'uniform sampler2D Texture2;'</span>,
            <span class="hljs-string">'uniform mat4 projection;'</span>,
            <span class="hljs-string">'uniform vec2 noiseSampling;'</span>,
            <span class="hljs-string">'uniform float Power;'</span>, <span class="hljs-comment">//'+ '{ 'min': 0.1, 'max': 16.0, 'step': 0.1, 'value': 1.0 }',</span>
            <span class="hljs-string">'uniform float Radius;'</span>, <span class="hljs-comment">//'+ '{ 'min': ' + ssaoRadiusMin +', 'max': ' + ssaoRadiusMax + ', 'step': '+ ssaoRadiusStep + ', 'value': 0.01 }',</span>
            <span class="hljs-string">'uniform float AngleLimit;'</span>,
            <span class="hljs-string">'#define NB_SAMPLES '</span> + <span class="hljs-keyword">this</span>._nbSamples,
            <span class="hljs-string">'float depth;'</span>,
            <span class="hljs-string">'float znear, zfar, zrange;'</span>,
            <span class="hljs-string">'vec3 normal;'</span>,
            <span class="hljs-string">'vec3 position;'</span>,
            <span class="hljs-string">'vec4 kernel['</span> + nbSamples + <span class="hljs-string">'];'</span>,

            Composer.Filter.shaderUtils,

            <span class="hljs-string">'mat3 computeBasis()'</span>,
            <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'  vec2 uvrand = FragTexCoord0*noiseSampling;'</span>,
            <span class="hljs-string">'  //uvrand = rand(gl_FragCoord.xy);'</span>,
            <span class="hljs-string">'  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);'</span>,
            <span class="hljs-string">'  //vec3 rvec = normalize(vec3(uvrand,0.0));'</span>,
            <span class="hljs-string">'  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));'</span>,
            <span class="hljs-string">'  vec3 bitangent = cross(normal, tangent);'</span>,
            <span class="hljs-string">'  mat3 tbn = mat3(tangent, bitangent, normal);'</span>,
            <span class="hljs-string">'  return tbn;'</span>,
            <span class="hljs-string">'}'</span>,

            <span class="hljs-string">'float getDepthValue(vec4 v) {'</span>,
            <span class="hljs-string">'  float depth = unpack4x8ToFloat(v);'</span>,
            <span class="hljs-string">'  depth = depth*zrange+znear;'</span>,
            <span class="hljs-string">'  //depth = depth*zrange;'</span>,
            <span class="hljs-string">'  return -depth;'</span>,
            <span class="hljs-string">'}'</span>,

            <span class="hljs-string">'void main (void)'</span>,
            <span class="hljs-string">'{'</span>,
            kernelglsl,
            <span class="hljs-string">'  vec4 p = texture2D(Texture0, FragTexCoord0);'</span>,
            <span class="hljs-string">'  if (dot(p,p) &lt; 0.001) { '</span>,
            <span class="hljs-string">'     gl_FragColor = vec4(1.0,1.0,1.0,0.0);'</span>,
            <span class="hljs-string">'     return;'</span>,
            <span class="hljs-string">'  }'</span>,
            <span class="hljs-string">'  znear = projection[3][2] / (projection[2][2]-1.0);'</span>,
            <span class="hljs-string">'  zfar = projection[3][2] / (projection[2][2]+1.0);'</span>,
            <span class="hljs-string">'  zrange = zfar-znear;'</span>,
            <span class="hljs-string">'  depth = getDepthValue(texture2D(Texture1, FragTexCoord0));'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>B = (A - znear)/(zfar-znear);’,
B = A/(zfar-znear) - znear/(zfar-znear);’,
B+ znear/(zfar-znear) = A/(zfar-znear) ;’,
(zfar-znear)<em>(B+ znear/(zfar-znear)) = A ;’,
(zfar-znear)</em>B+ znear = A ;’,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-string">'  if ( -depth &lt; znear) {'</span>,
            <span class="hljs-string">'     gl_FragColor = vec4(1.0,1.0,1.0,0.0);'</span>,
            <span class="hljs-string">'     return;'</span>,
            <span class="hljs-string">'  }'</span>,

            <span class="hljs-string">'  normal = decodeNormal(unpack4x8To2Float(p));'</span>,

            <span class="hljs-string">'  position = -FragTexCoord1*depth;'</span>,
            <span class="hljs-string">'  position.z = -position.z;'</span>,

            <span class="hljs-string">''</span>,
            <span class="hljs-string">' mat3 tbn = computeBasis();'</span>,
            <span class="hljs-string">' float occlusion = 0.0;'</span>,
            <span class="hljs-string">' for (int i = 0; i &lt; NB_SAMPLES; i++) {'</span>,
            <span class="hljs-string">'    vec3 vecKernel = vec3(kernel[i]);'</span>,
            <span class="hljs-string">'    vecKernel[2] = max(AngleLimit,vecKernel[2]);'</span>,
            <span class="hljs-string">'    vec3 sample = tbn * vec3(vecKernel);'</span>,
            <span class="hljs-string">'    vec3 dir = sample;'</span>,
            <span class="hljs-string">'    float w = dot(dir, normal);'</span>,
            <span class="hljs-string">'    float dist = 1.0-kernel[i].w;'</span>,
            <span class="hljs-string">'    w *= dist*dist*Power;'</span>,
            <span class="hljs-string">'    sample = dir * float(Radius) + position.xyz;'</span>,

            <span class="hljs-string">'    vec4 offset = projection * vec4(sample,1.0);'</span>,
            <span class="hljs-string">'    offset.xy /= offset.w;'</span>,
            <span class="hljs-string">'    offset.xy = offset.xy * 0.5 + 0.5;'</span>,

            <span class="hljs-string">'    float sample_depth = getDepthValue(texture2D(Texture1, offset.xy));'</span>,
            <span class="hljs-string">'    float range_check = abs(sample.z - sample_depth) &lt; float(Radius) ? 1.0 : 0.0;'</span>,
            <span class="hljs-string">'    occlusion += (sample_depth &gt; sample.z ? 1.0 : 0.0) * range_check*w;'</span>,

            <span class="hljs-string">' }'</span>,
            <span class="hljs-string">' occlusion = 1.0 - (occlusion / float(NB_SAMPLES));'</span>,
            <span class="hljs-string">' gl_FragColor = vec4(vec3(occlusion),1.0);'</span>,
            <span class="hljs-string">'}'</span>,
            <span class="hljs-string">''</span>
        ].join( <span class="hljs-string">'\n'</span> );

        <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> Program(
            <span class="hljs-keyword">new</span> Shader( Shader.VERTEX_SHADER, vertexShader + <span class="hljs-keyword">this</span>.getDefineVertexName() ),
            <span class="hljs-keyword">new</span> Shader( Shader.FRAGMENT_SHADER, fragmentShader + <span class="hljs-keyword">this</span>.getDefineFragmentName() ) );

        stateSet.setAttributeAndModes( program );
        <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">false</span>;
    }
} );

<span class="hljs-built_in">module</span>.exports = Composer;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
